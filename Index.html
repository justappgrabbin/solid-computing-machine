<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Code Ingester - Offline Causal Graph Platform</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0c0e14;
            color: #60a5fa;
            line-height: 1.6;
            overflow-x: hidden;
            height: 100vh;
            -webkit-tap-highlight-color: transparent;
            -webkit-text-size-adjust: 100%;
        }

        .bg-grid {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image:
                linear-gradient(rgba(96,165,250,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(96,165,250,0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            pointer-events: none;
        }

        .container { max-width: 1800px; margin: 0 auto; padding: 10px; height: 100vh; display: flex; flex-direction: column; }

        header {
            text-align: center; padding: 12px 0; border-bottom: 2px solid #60a5fa;
            margin-bottom: 10px; flex-shrink: 0;
        }
        h1 { font-size: 1.4em; text-shadow: 0 0 15px #60a5fa, 0 0 30px rgba(96,165,250,0.3); margin-bottom: 4px; letter-spacing: 2px; }
        .subtitle { color: #3b82f6; font-size: 0.85em; }

        .pyodide-status {
            display: inline-block; padding: 4px 14px; border: 1px solid #3b82f6;
            font-size: 0.8em; margin-top: 8px; border-radius: 12px;
        }
        .pyodide-status.loading { color: #f59e0b; border-color: #f59e0b; }
        .pyodide-status.ready { color: #60a5fa; border-color: #60a5fa; background: rgba(96,165,250,0.1); }
        .pyodide-status.error { color: #ef4444; border-color: #ef4444; }

        .nav-tabs {
            display: none; gap: 6px; margin-bottom: 15px; flex-wrap: wrap; flex-shrink: 0;
        }
        .nav-tab {
            padding: 10px 20px; background: #12151e; border: 2px solid #3b82f6;
            cursor: pointer; transition: all 0.3s; font-family: inherit;
            color: #60a5fa; font-size: 0.9em; border-radius: 10px;
        }
        .nav-tab:hover { background: #60a5fa; color: #0c0e14; }
        .nav-tab.active { background: #3b82f6; color: #0c0e14; box-shadow: 0 0 15px rgba(96,165,250,0.4); }

        .tab-content { display: none; flex: 1; overflow: auto; }
        .tab-content.active { display: flex; flex-direction: column; }

        .section {
            background: #12151e; border: 2px solid #3b82f6; padding: 14px;
            margin-bottom: 12px; box-shadow: 0 0 15px rgba(96,165,250,0.05);
            border-radius: 12px;
        }
        h2 { color: #60a5fa; margin-bottom: 15px; text-shadow: 0 0 5px rgba(96,165,250,0.5); font-size: 1.5em; }
        h3 { color: #93c5fd; margin: 15px 0 8px 0; font-size: 1.15em; }

        .upload-zone {
            border: 3px dashed #3b82f6; padding: 40px 20px; text-align: center;
            cursor: pointer; transition: all 0.3s; background: rgba(96,165,250,0.02);
            margin-bottom: 12px; border-radius: 14px;
        }
        .upload-zone:hover, .upload-zone.dragover {
            border-color: #60a5fa; background: rgba(96,165,250,0.08);
            box-shadow: 0 0 30px rgba(96,165,250,0.15);
        }
        .upload-icon { font-size: 3em; margin-bottom: 10px; display: block; }

        .badge {
            display: inline-block; padding: 3px 10px; border: 1px solid #3b82f6;
            font-size: 0.75em; margin: 3px; color: #3b82f6; border-radius: 8px;
        }

        input, textarea, select {
            width: 100%; padding: 12px; background: #0c0e14; border: 2px solid #3b82f6;
            color: #60a5fa; font-family: inherit; font-size: 1em;
            border-radius: 10px; min-height: 44px;
        }
        input:focus, textarea:focus, select:focus {
            outline: none; border-color: #60a5fa; box-shadow: 0 0 10px rgba(96,165,250,0.3);
        }
        textarea { min-height: 120px; resize: vertical; }

        button {
            padding: 12px 24px; background: #3b82f6; border: 2px solid #60a5fa;
            color: #0c0e14; cursor: pointer; font-family: inherit; font-size: 0.95em;
            font-weight: bold; transition: all 0.3s; margin-right: 8px; margin-top: 8px;
            border-radius: 10px; min-height: 44px;
        }
        button:hover { background: #60a5fa; box-shadow: 0 0 15px rgba(96,165,250,0.5); }
        button:active { transform: scale(0.97); }
        button.secondary { background: #1a1e2e; color: #60a5fa; }
        button.secondary:hover { background: #252a38; }
        button.danger { background: #581c1c; border-color: #ef4444; color: #ef4444; }
        button.danger:hover { background: #ef4444; color: #0c0e14; }

        .file-list-item {
            display: flex; align-items: center; gap: 10px; padding: 10px 12px;
            background: #141722; border-left: 3px solid #3b82f6; margin-bottom: 6px;
            cursor: pointer; transition: all 0.2s; border-radius: 8px;
            min-height: 44px;
        }
        .file-list-item:hover { background: #1a1e2e; border-left-color: #60a5fa; }
        .file-list-item.selected { background: #1a2540; border-left-color: #60a5fa; }
        .file-lang { font-size: 0.75em; color: #3b82f6; padding: 2px 6px; border: 1px solid #3b82f6; border-radius: 6px; }
        .file-name { flex: 1; font-size: 0.9em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .file-remove-btn {
            background: none; border: none; color: #ef4444; cursor: pointer;
            font-size: 0.85em; padding: 2px 6px; margin: 0;
        }
        .file-remove-btn:hover { color: #fb7185; background: none; box-shadow: none; }

        .code-viewer {
            background: #0c0e14; border: 2px solid #3b82f6; font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.85em; overflow: auto; position: relative; border-radius: 10px;
        }
        .code-viewer pre {
            padding: 15px; margin: 0; white-space: pre; tab-size: 4;
            counter-reset: line;
        }
        .code-line {
            display: block; padding-left: 50px; position: relative; min-height: 1.4em;
        }
        .code-line::before {
            counter-increment: line; content: counter(line);
            position: absolute; left: 0; width: 40px; text-align: right;
            color: #3d4555; padding-right: 8px; border-right: 1px solid #252a38;
            font-size: 0.85em;
        }
        .code-viewer-header {
            padding: 8px 15px; background: #141722; border-bottom: 1px solid #3b82f6;
            display: flex; justify-content: space-between; align-items: center;
            font-size: 0.85em; border-radius: 10px 10px 0 0;
        }

        .split-view { display: flex; flex-direction: column; gap: 12px; flex: 1; min-height: 0; }
        .split-left { width: 100%; max-height: 200px; flex-shrink: 0; overflow-y: auto; }
        .split-right { flex: 1; display: flex; flex-direction: column; min-width: 0; }

        #graph-container {
            flex: 1; background: #0c0e14; border: 2px solid #3b82f6;
            position: relative; min-height: 350px; border-radius: 10px;
        }
        #graph-container svg { width: 100%; height: 100%; }
        .graph-legend {
            position: absolute; top: 10px; right: 10px; background: rgba(10,10,10,0.9);
            border: 1px solid #3b82f6; padding: 10px; font-size: 0.8em; border-radius: 10px;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        .graph-controls {
            padding: 10px; background: #12151e; border: 2px solid #3b82f6;
            border-bottom: none; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
            border-radius: 10px 10px 0 0;
        }

        .node-tooltip {
            position: absolute; background: #12151e; border: 2px solid #60a5fa;
            padding: 10px 15px; pointer-events: none; font-size: 0.85em;
            box-shadow: 0 0 20px rgba(96,165,250,0.3); z-index: 100; max-width: 300px;
            border-radius: 10px;
        }

        .cluster-card {
            background: #141722; border: 2px solid #3b82f6; padding: 14px;
            margin-bottom: 12px; border-radius: 10px;
        }
        .cluster-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 8px; }
        .cluster-url { color: #3b82f6; font-size: 0.85em; }
        .cluster-files { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .cluster-file-badge {
            padding: 4px 10px; background: #12151e; border: 1px solid #3b82f6;
            font-size: 0.8em; cursor: pointer; transition: all 0.2s; border-radius: 6px;
        }
        .cluster-file-badge:hover { background: #1a2a1a; border-color: #60a5fa; }

        .gap-card {
            background: #141722; border-left: 4px solid #f59e0b; padding: 14px;
            margin-bottom: 10px; border-radius: 8px;
        }
        .gap-card.info { border-left-color: #38bdf8; }
        .gap-severity { font-size: 0.8em; padding: 2px 8px; border: 1px solid; display: inline-block; margin-bottom: 8px; border-radius: 6px; }
        .gap-severity.warning { color: #f59e0b; border-color: #f59e0b; }
        .gap-severity.info { color: #38bdf8; border-color: #38bdf8; }

        .preset-card {
            background: #141722; border: 2px solid #3b82f6; padding: 14px;
            margin-bottom: 10px; cursor: pointer; transition: all 0.3s; border-radius: 10px;
        }
        .preset-card:hover { border-color: #60a5fa; background: #1a2540; }
        .preset-card.selected { border-color: #60a5fa; background: #1a2540; box-shadow: 0 0 15px rgba(96,165,250,0.2); }
        .preset-name { font-size: 1.1em; color: #60a5fa; margin-bottom: 4px; }
        .preset-desc { color: #3b82f6; font-size: 0.85em; }

        .style-preview-split { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
        .style-preview-pane { flex: 1; min-width: 0; }
        .style-preview-label { padding: 6px 12px; background: #12151e; border: 1px solid #3b82f6; margin-bottom: -2px; font-size: 0.8em; display: inline-block; border-radius: 8px 8px 0 0; }

        .preview-frame-container {
            flex: 1; background: #fff; border: 2px solid #3b82f6; position: relative;
            min-height: 300px; border-radius: 10px; overflow: hidden;
        }
        .preview-frame-container iframe { width: 100%; height: 100%; border: none; min-height: 400px; }
        .preview-controls {
            padding: 10px 15px; background: #12151e; border: 2px solid #3b82f6;
            border-bottom: none; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
            border-radius: 10px 10px 0 0;
        }
        .viewport-btn { padding: 8px 14px; background: #1a1e2e; border: 1px solid #3b82f6; color: #60a5fa; cursor: pointer; font-family: inherit; font-size: 0.85em; margin: 0; border-radius: 8px; min-height: 44px; }
        .viewport-btn.active { background: #3b82f6; color: #0c0e14; }
        .console-output {
            background: #0c0e14; border: 2px solid #2a3040; padding: 10px;
            font-size: 0.8em; max-height: 150px; overflow-y: auto; margin-top: 10px;
            color: #8899aa; border-radius: 10px;
        }
        .console-log { color: #8899aa; }
        .console-warn { color: #f59e0b; }
        .console-error { color: #ef4444; }

        .export-card {
            background: #141722; border: 2px solid #3b82f6; padding: 16px;
            margin-bottom: 12px; display: flex; justify-content: space-between;
            align-items: center; flex-wrap: wrap; gap: 12px; border-radius: 10px;
        }
        .export-info h3 { margin: 0 0 5px 0; }
        .export-info p { color: #3b82f6; font-size: 0.85em; }

        .pyodide-console {
            background: #0c0e14; border: 2px solid #3b82f6; padding: 14px;
            font-size: 0.85em; margin-top: 12px; border-radius: 10px;
        }
        .pyodide-console .output { color: #60a5fa; white-space: pre-wrap; max-height: 300px; overflow-y: auto; }
        .pyodide-console .error-output { color: #ef4444; }

        .stats-grid {
            display: grid; grid-template-columns: repeat(2, 1fr);
            gap: 10px; margin: 12px 0;
        }
        .stat-card {
            background: #0c0e14; border: 2px solid #3b82f6; padding: 12px; text-align: center;
            border-radius: 10px;
        }
        .stat-value { font-size: 2em; color: #60a5fa; font-weight: bold; }
        .stat-label { color: #3b82f6; font-size: 0.85em; margin-top: 4px; }

        .empty-state { text-align: center; padding: 60px 20px; color: #3b82f6; font-size: 1.1em; }

        .paste-area { margin-top: 15px; }

        /* ===== BRAIN SUBSYSTEM STYLES ===== */
        .brain-terminal {
            background: #0d0f18; border: 2px solid #2a2d50; padding: 0; margin-top: 10px;
            font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace; font-size: 0.8em;
            border-radius: 10px; overflow: hidden;
        }
        .brain-terminal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 10px; background: #1a1d40; border-bottom: 1px solid #2a2d50;
        }
        .brain-terminal-header span { color: #818cf8; font-size: 0.9em; font-weight: bold; }
        .brain-terminal-output {
            max-height: 200px; overflow-y: auto; padding: 8px 10px;
            color: #a5b4fc; white-space: pre-wrap; line-height: 1.4;
        }
        .brain-terminal-output .term-info { color: #7478b8; }
        .brain-terminal-output .term-success { color: #34d399; }
        .brain-terminal-output .term-error { color: #f87171; }
        .brain-terminal-output .term-rag { color: #f472b6; }
        .brain-terminal-output .term-mcp { color: #38bdf8; }
        .brain-terminal-output .term-sensual { color: #f59e0b; }
        .brain-terminal-output .term-sync { color: #818cf8; }

        .brain-search-box {
            display: flex; gap: 6px; margin-top: 8px;
        }
        .brain-search-box input {
            flex: 1; background: #141728; border: 1px solid #3a3d66; color: #a5b4fc;
            padding: 10px 12px; font-size: 0.85em; font-family: inherit;
            min-height: 44px; border-radius: 8px;
        }
        .brain-search-box input::placeholder { color: #3a3d66; }
        .brain-search-box button {
            padding: 10px 14px; font-size: 0.85em; margin: 0;
            background: #2a2d50; border: 1px solid #6366f1; color: #818cf8;
            min-height: 44px; border-radius: 8px;
        }

        .brain-rag-results {
            max-height: 160px; overflow-y: auto; margin-top: 6px;
        }
        .brain-rag-result {
            padding: 6px 8px; border-bottom: 1px solid #1a1d40; font-size: 0.78em;
            cursor: pointer;
        }
        .brain-rag-result:hover { background: rgba(99,102,241,0.1); }
        .brain-rag-score { color: #f472b6; font-weight: bold; }
        .brain-rag-source { color: #5558a0; }
        .brain-rag-text { color: #8b8fce; margin-top: 2px; }

        .brain-subsystem-badges {
            display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px;
        }
        .brain-subsystem-badge {
            padding: 4px 10px; font-size: 0.72em; border: 1px solid; display: inline-flex;
            align-items: center; gap: 4px; font-family: inherit; border-radius: 8px;
            min-height: 32px;
        }
        .brain-subsystem-badge.active { opacity: 1; }
        .brain-subsystem-badge.inactive { opacity: 0.4; }

        .brain-mcp-panel {
            background: #0d0f18; border: 2px solid #335588; padding: 10px; margin-top: 8px;
            border-radius: 10px;
        }
        .brain-mcp-entry {
            padding: 4px 6px; font-size: 0.78em; border-bottom: 1px solid #1a1d40;
            display: flex; justify-content: space-between; align-items: center;
        }
        .brain-mcp-entry .mcp-name { color: #38bdf8; }
        .brain-mcp-entry .mcp-status { font-size: 0.7em; }
        .mcp-connected { color: #34d399; }
        .mcp-disconnected { color: #f87171; }

        /* ===== BRAIN TAB STYLES ===== */
        .brain-layout { display: flex; flex-direction: column; gap: 12px; flex: 1; min-height: 0; }
        .brain-sidebar { width: 100%; max-height: 250px; flex-shrink: 0; overflow-y: auto; }
        .brain-main { flex: 1; display: flex; flex-direction: column; min-width: 0; }

        #brainContainer {
            flex: 1; background: #0d0f18; border: 2px solid #6366f1; position: relative; min-height: 300px;
            border-radius: 10px;
        }
        #brainContainer svg { width: 100%; height: 100%; }

        .brain-controls {
            padding: 10px; background: #141728; border: 2px solid #6366f1;
            border-bottom: none; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
            border-radius: 10px 10px 0 0; overflow-x: auto; -webkit-overflow-scrolling: touch;
        }
        .brain-controls button {
            background: #4f46e5; border-color: #7c7cf8; color: #fff;
        }
        .brain-controls button:hover {
            background: #7c7cf8; box-shadow: 0 0 15px rgba(124,124,248,0.5);
        }
        .brain-controls button.secondary { background: #141728; color: #a5b4fc; border-color: #2a2d50; }
        .brain-controls button.secondary:hover { background: #1a1d40; }

        .brain-center-card {
            background: #141728; border: 2px solid #2a2d50; padding: 14px;
            margin-bottom: 10px; transition: all 0.3s; cursor: pointer;
            border-radius: 10px; min-height: 44px;
        }
        .brain-center-card:hover { border-color: #7c7cf8; }
        .brain-center-card.active { border-color: #818cf8; box-shadow: 0 0 15px rgba(129,140,248,0.2); }
        .brain-center-title { font-size: 1.05em; margin-bottom: 4px; }
        .brain-center-subtitle { font-size: 0.8em; color: #7478b8; margin-bottom: 8px; }
        .brain-center-meter {
            height: 6px; background: #1a1d40; margin-top: 6px; overflow: hidden;
            border-radius: 3px;
        }
        .brain-center-meter-fill { height: 100%; transition: width 0.4s; }

        .brain-info-panel {
            background: #0d0f18; border: 2px solid #6366f1; padding: 12px; margin-top: 12px;
            font-size: 0.85em; max-height: 250px; overflow-y: auto; border-radius: 10px;
        }
        .brain-info-panel h4 { color: #818cf8; margin-bottom: 8px; }
        .brain-info-row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid #1a1d40; gap: 8px; }
        .brain-info-key { color: #8b8fce; }
        .brain-info-val { color: #a5b4fc; text-align: right; }

        .brain-interference-panel {
            background: #0d0f18; border: 2px solid #3a3d66; padding: 12px; margin-top: 12px;
            border-radius: 10px;
        }
        .brain-interference-panel h4 { color: #818cf8; margin-bottom: 8px; font-size: 0.95em; }
        .interference-row { display: flex; justify-content: space-between; padding: 4px 0; align-items: center; }
        .interference-label { color: #8b8fce; font-size: 0.85em; }
        .interference-value { font-weight: bold; font-size: 0.95em; }
        .interference-bar { flex: 1; height: 4px; background: #1a1d40; margin: 0 10px; overflow: hidden; border-radius: 2px; }
        .interference-bar-fill { height: 100%; transition: width 0.4s; }

        .brain-doc-list {
            max-height: 200px; overflow-y: auto; margin-top: 10px;
        }
        .brain-doc-item {
            display: flex; align-items: center; gap: 8px; padding: 10px 12px;
            background: #141728; border-left: 3px solid #3a3d66; margin-bottom: 4px;
            font-size: 0.85em; cursor: pointer; transition: all 0.2s;
            border-radius: 8px; min-height: 44px;
        }
        .brain-doc-item:hover { background: #1a1d40; border-left-color: #7c7cf8; }
        .brain-doc-center-badge {
            padding: 2px 6px; font-size: 0.7em; border: 1px solid; display: inline-block;
            border-radius: 6px;
        }

        .brain-tooltip {
            position: absolute; background: #141728; border: 2px solid #7c7cf8;
            padding: 12px; pointer-events: none; z-index: 200; max-width: 350px;
            font-size: 0.82em; box-shadow: 0 0 25px rgba(124,124,248,0.4);
            border-radius: 10px;
        }

        .causal-engine-layout { display: flex; flex-direction: column; gap: 12px; flex: 1; min-height: 0; }
        .causal-sidebar { width: 100%; max-height: 250px; flex-shrink: 0; overflow-y: auto; }
        .causal-main { flex: 1; display: flex; flex-direction: column; min-width: 0; }

        #causalGraphContainer {
            flex: 1; background: #0e0c14; border: 2px solid #db2777; position: relative; min-height: 300px;
            border-radius: 10px;
        }
        #causalGraphContainer svg { width: 100%; height: 100%; }

        .causal-node-palette { margin-bottom: 12px; }
        .palette-category {
            margin-bottom: 10px; padding: 10px; background: #181420; border: 1px solid #3a2040;
            border-radius: 10px;
        }
        .palette-category-title {
            font-size: 0.8em; color: #f9a8d4; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px;
        }
        .palette-node-btn {
            display: block; width: 100%; padding: 10px 12px; background: #181420; border: 1px solid #3a2040;
            color: #fbb6ce; cursor: pointer; font-family: inherit; font-size: 0.85em;
            text-align: left; margin-bottom: 4px; transition: all 0.2s;
            border-radius: 8px; min-height: 44px;
        }
        .palette-node-btn:hover { border-color: #f472b6; background: #281a30; box-shadow: none; }
        .palette-node-btn .node-dot {
            display: inline-block; width: 10px; height: 10px; border-radius: 50%;
            margin-right: 6px; vertical-align: middle;
        }

        .causal-info-panel {
            background: #0e0c14; border: 2px solid #db2777; padding: 12px; margin-top: 12px;
            font-size: 0.85em; max-height: 250px; overflow-y: auto; border-radius: 10px;
        }
        .causal-info-panel h4 { color: #f9a8d4; margin-bottom: 8px; }
        .causal-info-row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid #181420; gap: 8px; }
        .causal-info-key { color: #f9a8d4; }
        .causal-info-val { color: #fbb6ce; text-align: right; }

        .causal-equation {
            background: #0e0c14; border: 2px solid #5a2d50; padding: 12px 15px;
            font-size: 0.9em; color: #f9a8d4; margin: 10px 0; text-align: center;
            font-style: italic; letter-spacing: 0.5px; border-radius: 10px;
        }

        .causal-controls {
            padding: 10px; background: #181420; border: 2px solid #db2777;
            border-bottom: none; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
            border-radius: 10px 10px 0 0; overflow-x: auto; -webkit-overflow-scrolling: touch;
        }

        .sim-panel { background: #0e0c14; border: 2px solid #db2777; padding: 14px; margin-top: 12px; border-radius: 10px; }
        .sim-readout {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px; margin-top: 10px;
        }
        .sim-cell {
            background: #181420; border: 1px solid #3a2040; padding: 8px; text-align: center;
            border-radius: 8px;
        }
        .sim-cell-label { font-size: 0.7em; color: #f9a8d4; text-transform: uppercase; }
        .sim-cell-value { font-size: 1.4em; color: #f472b6; font-weight: bold; margin-top: 2px; }
        .sim-cell-bar {
            height: 4px; background: #181420; margin-top: 4px; overflow: hidden;
            border-radius: 2px;
        }
        .sim-cell-bar-fill { height: 100%; background: #f472b6; transition: width 0.3s; }

        .operator-badge {
            display: inline-block; padding: 2px 8px; border: 1px solid #f9a8d4;
            color: #f9a8d4; font-size: 0.75em; margin: 2px; font-style: italic;
            border-radius: 6px;
        }

        .causal-tooltip {
            position: absolute; background: #181420; border: 2px solid #f472b6;
            padding: 12px; pointer-events: none; z-index: 200; max-width: 350px;
            font-size: 0.82em; box-shadow: 0 0 25px rgba(244,114,182,0.4);
            border-radius: 10px;
        }

        .causal-controls button, .causal-sidebar button:not(.palette-node-btn) {
            background: #be185d; border-color: #f472b6; color: #fff;
        }
        .causal-controls button:hover, .causal-sidebar button:not(.palette-node-btn):hover {
            background: #f472b6; box-shadow: 0 0 15px rgba(244,114,182,0.5);
        }
        .causal-controls button.secondary { background: #181420; color: #fbb6ce; border-color: #5a2d50; }
        .causal-controls button.secondary:hover { background: #281a30; }

        .mobile-tab-dropdown {
            display: block; position: relative; margin-bottom: 10px; flex-shrink: 0;
        }
        .mobile-tab-trigger {
            width: 100%; padding: 12px 16px; background: #12151e; border: 2px solid #3b82f6;
            color: #60a5fa; font-family: inherit; font-size: 1em; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            border-radius: 10px; min-height: 48px;
        }
        .mobile-tab-trigger:hover { border-color: #60a5fa; }
        .mobile-tab-trigger .arrow { transition: transform 0.2s; }
        .mobile-tab-trigger.open .arrow { transform: rotate(180deg); }
        .mobile-tab-menu {
            display: none; position: absolute; top: 100%; left: 0; right: 0;
            background: #12151e; border: 2px solid #3b82f6; border-top: none;
            z-index: 500; max-height: 70vh; overflow-y: auto;
            border-radius: 0 0 10px 10px;
        }
        .mobile-tab-menu.open { display: block; }
        .mobile-tab-option {
            display: block; width: 100%; padding: 14px 16px; background: none;
            border: none; border-bottom: 1px solid #1a1e2e; color: #60a5fa;
            font-family: inherit; font-size: 0.95em; cursor: pointer; text-align: left;
            margin: 0; min-height: 48px; border-radius: 0;
        }
        .mobile-tab-option:hover { background: #1a2540; }
        .mobile-tab-option.active { background: #3b82f6; color: #0c0e14; font-weight: bold; }

        @media (min-width: 769px) {
            .container { padding: 15px; }
            header { padding: 20px 0; }
            h1 { font-size: 2.2em; letter-spacing: 3px; }
            .subtitle { font-size: 0.95em; }
            .nav-tabs { display: flex; }
            .mobile-tab-dropdown { display: none; }
            .split-view { flex-direction: row; gap: 15px; }
            .split-left { width: 280px; max-height: none; }
            .style-preview-split { flex-direction: row; gap: 15px; }
            .brain-layout { flex-direction: row; gap: 15px; }
            .brain-sidebar { width: 320px; max-height: none; }
            .causal-engine-layout { flex-direction: row; gap: 15px; }
            .causal-sidebar { width: 320px; max-height: none; }
            #graph-container { min-height: 500px; }
            #brainContainer { min-height: 500px; }
            #causalGraphContainer { min-height: 500px; }
            .stats-grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
            .section { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    <div class="container">
        <header>
            <h1>&lt;/&gt; CODE INGESTER</h1>
            <div class="subtitle">Offline Causal Graph Platform | Powered by Pyodide</div>
            <div id="pyodideStatus" class="pyodide-status loading">LOADING PYODIDE...</div>
        </header>

        <div class="nav-tabs" id="desktopTabs">
            <button class="nav-tab active" data-tab="upload">Upload</button>
            <button class="nav-tab" data-tab="files">Files</button>
            <button class="nav-tab" data-tab="graph">Dependency Graph</button>
            <button class="nav-tab" data-tab="clusters">Clusters</button>
            <button class="nav-tab" data-tab="gaps">Gap Detection</button>
            <button class="nav-tab" data-tab="style">Style</button>
            <button class="nav-tab" data-tab="preview">Preview</button>
            <button class="nav-tab" data-tab="python">Python Console</button>
            <button class="nav-tab" data-tab="brain">Brain</button>
            <button class="nav-tab" data-tab="causal">Causal Engine</button>
            <button class="nav-tab" data-tab="export">Export</button>
            <button class="nav-tab" data-tab="makemodule">✦ Make Module</button>
            <button class="nav-tab" data-tab="myapps">⬡ My Apps</button>
        </div>

        <div class="mobile-tab-dropdown" id="mobileTabDropdown">
            <button class="mobile-tab-trigger" id="mobileTabTrigger" onclick="toggleMobileMenu()">
                <span id="mobileTabLabel">Upload</span>
                <span class="arrow">&#9660;</span>
            </button>
            <div class="mobile-tab-menu" id="mobileTabMenu">
                <button class="mobile-tab-option active" data-tab="upload">Upload</button>
                <button class="mobile-tab-option" data-tab="files">Files</button>
                <button class="mobile-tab-option" data-tab="graph">Dependency Graph</button>
                <button class="mobile-tab-option" data-tab="clusters">Clusters</button>
                <button class="mobile-tab-option" data-tab="gaps">Gap Detection</button>
                <button class="mobile-tab-option" data-tab="style">Style</button>
                <button class="mobile-tab-option" data-tab="preview">Preview</button>
                <button class="mobile-tab-option" data-tab="python">Python Console</button>
                <button class="mobile-tab-option" data-tab="brain">Brain</button>
                <button class="mobile-tab-option" data-tab="causal">Causal Engine</button>
                <button class="mobile-tab-option" data-tab="export">Export</button>
                <button class="mobile-tab-option" data-tab="makemodule">✦ Make Module</button>
                <button class="mobile-tab-option" data-tab="myapps">⬡ My Apps</button>
            </div>
        </div>

        <!-- UPLOAD TAB -->
        <div id="upload" class="tab-content active">
            <div class="section">
                <h2>Upload Code Files</h2>
                <div class="upload-zone" id="uploadZone">
                    <span class="upload-icon">&uarr;</span>
                    <div>Drop files here or click to browse</div>
                    <div style="color:#3b82f6; margin-top:8px; font-size:0.9em;">
                        Supports code files, PDFs, Word docs, ZIP archives
                    </div>
                    <div style="margin-top:12px;">
                        <span class="badge">.js</span><span class="badge">.py</span>
                        <span class="badge">.ts</span><span class="badge">.html</span>
                        <span class="badge">.css</span><span class="badge">.json</span>
                        <span class="badge">.zip</span><span class="badge">.tar.gz</span>
                        <span class="badge">.pdf</span><span class="badge">.docx</span>
                        <span class="badge">+ 40 more</span>
                    </div>
                    <input type="file" id="fileInput" multiple style="display:none;" accept="*/*">
                </div>
            </div>
            <div class="section">
                <h2>Paste Code</h2>
                <div class="paste-area">
                    <div style="display:flex;gap:10px;margin-bottom:10px;flex-wrap:wrap;">
                        <input type="text" id="pasteFilename" placeholder="Filename (e.g. app.js)" style="flex:1;min-width:150px;">
                        <select id="pasteLanguage" style="width:160px;">
                            <option value="">Auto-detect</option>
                            <option value="javascript">JavaScript</option>
                            <option value="typescript">TypeScript</option>
                            <option value="python">Python</option>
                            <option value="html">HTML</option>
                            <option value="css">CSS</option>
                            <option value="json">JSON</option>
                            <option value="java">Java</option>
                            <option value="cpp">C++</option>
                            <option value="go">Go</option>
                            <option value="rust">Rust</option>
                            <option value="ruby">Ruby</option>
                            <option value="php">PHP</option>
                            <option value="shell">Shell</option>
                            <option value="sql">SQL</option>
                            <option value="markdown">Markdown</option>
                        </select>
                    </div>
                    <textarea id="pasteContent" placeholder="Paste your code here..."></textarea>
                    <button onclick="addPastedCode()">Add Code</button>
                </div>
            </div>
            <div class="section">
                <h2>Project Files (<span id="fileCountUpload">0</span>)</h2>
                <div id="uploadedFilesList"></div>
            </div>
        </div>

        <!-- FILES TAB -->
        <div id="files" class="tab-content">
            <div class="split-view" style="height:calc(100vh - 200px);">
                <div class="split-left">
                    <div class="section" style="height:100%;display:flex;flex-direction:column;margin-bottom:0;">
                        <h3 style="margin-top:0;">File Explorer (<span id="fileCountExplorer">0</span>)</h3>
                        <div id="fileExplorer" style="flex:1;overflow-y:auto;"></div>
                    </div>
                </div>
                <div class="split-right">
                    <div class="code-viewer" style="flex:1;display:flex;flex-direction:column;">
                        <div class="code-viewer-header">
                            <span id="viewerFilename">Select a file to view</span>
                            <span id="viewerLanguage" class="file-lang" style="display:none;"></span>
                        </div>
                        <div style="flex:1;overflow:auto;">
                            <pre id="codeContent"><span style="color:#3b82f6;padding:15px;display:block;">Click a file on the left to view its contents</span></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DEPENDENCY GRAPH TAB -->
        <div id="graph" class="tab-content">
            <div class="graph-controls">
                <span style="color:#3b82f6;">Layout:</span>
                <button class="secondary" onclick="setGraphLayout('force')" style="margin:0;padding:6px 14px;">Force</button>
                <button class="secondary" onclick="setGraphLayout('radial')" style="margin:0;padding:6px 14px;">Radial</button>
                <button class="secondary" onclick="setGraphLayout('tree')" style="margin:0;padding:6px 14px;">Tree</button>
                <span style="margin-left:20px;color:#3b82f6;">Zoom:</span>
                <button class="secondary" onclick="graphZoom(1.3)" style="margin:0;padding:6px 14px;">+</button>
                <button class="secondary" onclick="graphZoom(0.7)" style="margin:0;padding:6px 14px;">-</button>
                <button class="secondary" onclick="graphReset()" style="margin:0;padding:6px 14px;">Reset</button>
                <button onclick="buildGraph()" style="margin:0;padding:6px 14px;">Rebuild Graph</button>
            </div>
            <div id="graph-container">
                <svg id="graphSvg"></svg>
                <div class="graph-legend" id="graphLegend"></div>
                <div class="node-tooltip" id="nodeTooltip" style="display:none;"></div>
            </div>
        </div>

        <!-- CLUSTERS TAB -->
        <div id="clusters" class="tab-content">
            <div class="section">
                <h2>URL-Based Clusters</h2>
                <p style="color:#3b82f6;margin-bottom:15px;">Group files by page or route. Drag files between clusters or assign them below.</p>
                <div style="display:flex;gap:10px;margin-bottom:15px;flex-wrap:wrap;">
                    <input type="text" id="newClusterName" placeholder="Cluster name" style="flex:1;min-width:150px;">
                    <input type="text" id="newClusterUrl" placeholder="URL path (e.g. /dashboard)" style="flex:1;min-width:150px;">
                    <button onclick="addCluster()">Add Cluster</button>
                </div>
            </div>
            <div id="clustersList"></div>
            <div class="section" id="unassignedFilesSection" style="display:none;">
                <h3>Unassigned Files</h3>
                <div id="unassignedFiles"></div>
            </div>
        </div>

        <!-- GAP DETECTION TAB -->
        <div id="gaps" class="tab-content">
            <div class="section">
                <h2>Gap Detection</h2>
                <p style="color:#3b82f6;margin-bottom:15px;">Scan your project for missing imports, config files, entry points, and dependencies.</p>
                <button onclick="runGapDetection()">Scan for Gaps</button>
                <button class="secondary" onclick="runPyodideGapDetection()">Deep Scan (Pyodide)</button>
            </div>
            <div id="gapResults"></div>
        </div>

        <!-- STYLE TAB -->
        <div id="style" class="tab-content">
            <div class="section">
                <h2>Code Style Uniformity</h2>
                <p style="color:#3b82f6;margin-bottom:15px;">Choose a preset to unify code style across all files.</p>
                <div id="stylePresets"></div>
                <div id="stylePreviewArea" style="display:none;">
                    <h3>Preview</h3>
                    <div class="style-preview-split">
                        <div class="style-preview-pane">
                            <div class="style-preview-label">BEFORE</div>
                            <div class="code-viewer" style="max-height:300px;">
                                <pre id="stylePreviewBefore"></pre>
                            </div>
                        </div>
                        <div class="style-preview-pane">
                            <div class="style-preview-label">AFTER</div>
                            <div class="code-viewer" style="max-height:300px;">
                                <pre id="stylePreviewAfter"></pre>
                            </div>
                        </div>
                    </div>
                    <button onclick="applyStyleToAll()" style="margin-top:15px;">Apply to All Files</button>
                </div>
            </div>
        </div>

        <!-- PREVIEW TAB -->
        <div id="preview" class="tab-content">
            <div class="preview-controls">
                <button onclick="runPreview()" style="margin:0;">Run Preview</button>
                <span style="margin-left:15px;color:#3b82f6;">Viewport:</span>
                <button class="viewport-btn active" onclick="setViewport(this,'100%')" style="margin:0;">Desktop</button>
                <button class="viewport-btn" onclick="setViewport(this,'768px')" style="margin:0;">Tablet</button>
                <button class="viewport-btn" onclick="setViewport(this,'375px')" style="margin:0;">Mobile</button>
            </div>
            <div class="preview-frame-container" id="previewContainer">
                <iframe id="previewFrame" sandbox="allow-scripts allow-same-origin"></iframe>
            </div>
            <div class="console-output" id="previewConsole">
                <div style="color:#3d4555;">Console output will appear here...</div>
            </div>
        </div>

        <!-- PYTHON CONSOLE TAB -->
        <div id="python" class="tab-content">
            <div class="section">
                <h2>Python Console (Pyodide)</h2>
                <p style="color:#3b82f6;margin-bottom:15px;">
                    Execute Python code in the browser. Access project files via the <code style="color:#60a5fa;">files</code> variable.
                </p>
                <textarea id="pythonCode" style="min-height:200px;" placeholder="# Python code runs in-browser via Pyodide
# Access project files:
#   files = list of dicts with keys: filename, path, content, language
#
# Example:
for f in files:
    print(f'File: {f[&quot;filename&quot;]} ({f[&quot;language&quot;]})')
    print(f'  Lines: {len(f[&quot;content&quot;].splitlines())}')
"></textarea>
                <button onclick="runPython()">Run Python</button>
                <button class="secondary" onclick="clearPythonOutput()">Clear Output</button>
            </div>
            <div class="pyodide-console">
                <h3>Output</h3>
                <div id="pythonOutput" class="output">Waiting for execution...</div>
            </div>
        </div>

        <!-- BRAIN TAB -->
        <div id="brain" class="tab-content">
            <div class="brain-controls">
                <button onclick="brainProcessFiles()" style="margin:0;padding:6px 14px;">Ingest Uploaded Files</button>
                <button onclick="brainProcessToGraph()" style="margin:0;padding:6px 14px;">Send to Causal Graph</button>
                <button class="secondary" onclick="brainZoom(1.3)" style="margin:0;padding:6px 14px;">+</button>
                <button class="secondary" onclick="brainZoom(0.7)" style="margin:0;padding:6px 14px;">-</button>
                <button onclick="brainPulse()" style="margin:0;padding:6px 14px;">Pulse</button>
                <button onclick="brainRunResonance()" style="margin:0;padding:6px 14px;">Run Resonance</button>
                <button class="danger" onclick="brainStopResonance()" style="margin:0;padding:6px 14px;">Stop</button>
                <button onclick="brainSyncAll()" style="margin:0;padding:6px 14px;background:#2a2d50;border-color:#6366f1;">Sync Brains</button>
                <button class="secondary" onclick="brainReset()" style="margin:0;padding:6px 14px;">Reset</button>
            </div>
            <div class="brain-layout" style="height:calc(100vh - 260px);">
                <div class="brain-sidebar">
                    <!-- Brain Knowledge Upload -->
                    <div style="background:#141728;border:2px solid #3a3d66;padding:12px;margin-bottom:10px;">
                        <h4 style="color:#818cf8;margin:0 0 8px 0;font-size:0.95em;">Brain Knowledge Upload</h4>
                        <div id="brainUploadZone" style="border:2px dashed #3a3d66;padding:20px 10px;text-align:center;cursor:pointer;background:rgba(99,102,241,0.03);margin-bottom:8px;font-size:0.85em;color:#8b8fce;">
                            Drop books, PDFs, docs, code here<br><span style="font-size:0.8em;color:#5558a0;">or click to browse</span>
                        </div>
                        <input type="file" id="brainFileInput" multiple style="display:none;" accept=".pdf,.txt,.md,.doc,.docx,.py,.js,.ts,.json,.html,.css,.yml,.yaml,.toml,.rb,.go,.rs,.java,.c,.cpp,.h,.sh,.sql">
                    </div>
                    <!-- 3 Awareness Centers -->
                    <div id="brainCenterCards"></div>
                    <!-- Interference Patterns -->
                    <div class="brain-interference-panel" id="brainInterference">
                        <h4>Interference Patterns</h4>
                        <div id="brainInterferenceReadout"></div>
                    </div>
                    <!-- Task Queue -->
                    <div style="background:#0d0f18;border:2px solid #3a3d66;padding:12px;margin-top:10px;">
                        <h4 style="color:#818cf8;margin:0 0 8px 0;font-size:0.95em;">Task Queue <span id="brainTaskCount" style="color:#8b8fce;font-size:0.8em;">(0)</span></h4>
                        <div id="brainTaskQueue" style="max-height:180px;overflow-y:auto;"></div>
                    </div>
                    <!-- RAG Search -->
                    <div style="background:#141728;border:2px solid #3a3d66;padding:10px;margin-top:10px;">
                        <h4 style="color:#f472b6;margin:0 0 6px 0;font-size:0.9em;">RAG Search (Emotional/Adaptive)</h4>
                        <div class="brain-search-box">
                            <input type="text" id="brainSearchInput" placeholder="Search knowledge base..." onkeydown="if(event.key==='Enter')brainRAGSearch()">
                            <button onclick="brainRAGSearch()">Search</button>
                        </div>
                        <div id="brainRAGResults" class="brain-rag-results"></div>
                    </div>
                    <!-- MCP Connections -->
                    <div class="brain-mcp-panel">
                        <h4 style="color:#38bdf8;margin:0 0 6px 0;font-size:0.9em;">MCP Protocols (Thought)</h4>
                        <div id="brainMCPList"></div>
                        <div style="margin-top:6px;">
                            <button onclick="brainRegisterMCP()" style="padding:3px 8px;font-size:0.75em;margin:0;background:#1e2a4a;border-color:#38bdf8;color:#7dd3fc;">+ Register Protocol</button>
                            <button onclick="brainSyncAll()" style="padding:3px 8px;font-size:0.75em;margin:0;background:#2a2d50;border-color:#6366f1;color:#818cf8;">Sync Brains</button>
                        </div>
                    </div>
                    <!-- Info Panel -->
                    <div class="brain-info-panel" id="brainInfoPanel">
                        <h4>Select an awareness center or processed item</h4>
                    </div>
                    <!-- Subsystem Status Badges -->
                    <div class="brain-subsystem-badges" id="brainSubsystemBadges"></div>
                </div>
                <div class="brain-main">
                    <div id="brainContainer">
                        <svg id="brainSvg"></svg>
                        <div class="brain-tooltip" id="brainTooltip" style="display:none;"></div>
                    </div>
                    <!-- Processed Items / Shop + Engine -->
                    <div style="display:flex;gap:10px;margin-top:10px;">
                        <div style="flex:1;background:#0d0f18;border:2px solid #2a2d50;padding:10px;">
                            <h4 style="color:#f59e0b;margin:0 0 6px 0;font-size:0.9em;">Shop <span style="font-size:0.75em;color:#8a6a30;">(stored for later)</span></h4>
                            <div id="brainShopList" class="brain-doc-list" style="max-height:140px;"></div>
                        </div>
                        <div style="flex:1;background:#0d0f18;border:2px solid #2a2d50;padding:10px;">
                            <h4 style="color:#34d399;margin:0 0 6px 0;font-size:0.9em;">Engine <span style="font-size:0.75em;color:#2a5a4a;">(active use)</span></h4>
                            <div id="brainEngineList" class="brain-doc-list" style="max-height:140px;"></div>
                        </div>
                    </div>
                    <!-- Brain Terminal -->
                    <div class="brain-terminal">
                        <div class="brain-terminal-header">
                            <span>Brain Terminal</span>
                            <div style="display:flex;gap:6px;">
                                <button onclick="brainTerminalClear()" style="padding:2px 8px;font-size:0.7em;margin:0;background:transparent;border-color:#2a2d50;color:#5558a0;">Clear</button>
                                <button onclick="brainRunPyodideCode()" style="padding:2px 8px;font-size:0.7em;margin:0;background:#1a1540;border-color:#6366f1;color:#818cf8;">Run Python</button>
                            </div>
                        </div>
                        <div id="brainTerminalOutput" class="brain-terminal-output">
                            <div class="term-info">[BRAIN] System initialized. Awaiting knowledge...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- CAUSAL ENGINE TAB -->
        <div id="causal" class="tab-content">
            <div class="causal-controls">
                <button onclick="causalLoadCanonical()" style="margin:0;padding:6px 14px;">Load Canonical Chain</button>
                <button onclick="convertFilesToCausal()" style="margin:0;padding:6px 14px;">Convert Files to Graph</button>
                <button class="secondary" onclick="causalClear()" style="margin:0;padding:6px 14px;">Clear Graph</button>
                <button class="secondary" onclick="causalZoom(1.3)" style="margin:0;padding:6px 14px;">+</button>
                <button class="secondary" onclick="causalZoom(0.7)" style="margin:0;padding:6px 14px;">-</button>
                <button class="secondary" onclick="causalResetZoom()" style="margin:0;padding:6px 14px;">Reset View</button>
                <button onclick="causalStepSim()" style="margin:0;padding:6px 14px;">Step t+1</button>
                <button onclick="causalRunSim()" style="margin:0;padding:6px 14px;">Run Simulation</button>
                <button class="danger" onclick="causalStopSim()" style="margin:0;padding:6px 14px;">Stop</button>
            </div>
            <div class="causal-engine-layout" style="height:calc(100vh - 260px);">
                <div class="causal-sidebar">
                    <div class="section" style="margin-bottom:10px;padding:12px;">
                        <h3 style="margin-top:0;font-size:1em;">Node Palette</h3>
                        <div id="causalPalette"></div>
                    </div>
                    <div class="section" style="margin-bottom:10px;padding:12px;">
                        <h3 style="margin-top:0;font-size:1em;">Operators</h3>
                        <div id="causalOperators"></div>
                    </div>
                    <div class="causal-equation" id="causalEquation">
                        x(t+1) = &sigma;( O(t) &middot; x(t) + R(t) )
                    </div>
                    <div class="causal-info-panel" id="causalInfoPanel">
                        <h4>Select a node for details</h4>
                    </div>
                </div>
                <div class="causal-main">
                    <div id="causalGraphContainer">
                        <svg id="causalSvg"></svg>
                        <div class="causal-tooltip" id="causalTooltip" style="display:none;"></div>
                    </div>
                    <div class="sim-panel">
                        <h3 style="margin-top:0;">Dimensional State Vector x(t) &mdash; <span id="simTimeStep">t=0</span></h3>
                        <div class="sim-readout" id="simReadout"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- EXPORT TAB -->
        <div id="export" class="tab-content">
            <div class="section">
                <h2>Export Project</h2>
                <div class="stats-grid" id="exportStats"></div>
            </div>
            <div class="export-card">
                <div class="export-info">
                    <h3>Download as ZIP</h3>
                    <p>GitHub-ready project archive with proper directory structure</p>
                </div>
                <button onclick="exportZip()">Download ZIP</button>
            </div>
            <div class="export-card">
                <div class="export-info">
                    <h3>Export as Standalone HTML</h3>
                    <p>Single HTML file with all code embedded, browsable offline</p>
                </div>
                <button onclick="exportHtml()">Export HTML</button>
            </div>
            <div class="export-card">
                <div class="export-info">
                    <h3>Export Dependency Report</h3>
                    <p>JSON report of all file dependencies and causal relationships</p>
                </div>
                <button onclick="exportDependencyReport()">Export Report</button>
            </div>
        </div>
    </div>

        <!-- ===== MAKE MODULE TAB ===== -->
        <div id="makemodule" class="tab-content">
            <div class="section">
                <h2>✦ Make Module</h2>
                <p style="color:#3b82f6;margin-bottom:16px;font-size:0.9em">Describe what you want. Drop in any file. It becomes a page in My Apps.</p>

                <div style="margin-bottom:12px">
                    <label style="display:block;margin-bottom:6px;color:#60a5fa;font-size:0.85em">MODULE NAME</label>
                    <input id="modName" type="text" placeholder="e.g. Human Design Oracle" style="width:100%;background:#12151e;border:1px solid #3b82f6;color:#60a5fa;padding:10px;border-radius:6px;font-size:0.9em;outline:none"/>
                </div>

                <div style="margin-bottom:12px">
                    <label style="display:block;margin-bottom:6px;color:#60a5fa;font-size:0.85em">WHAT DOES IT DO? (plain English)</label>
                    <textarea id="modDescription" placeholder="e.g. Takes a birth date and time, calculates the Human Design chart, shows gates and channels, lets user explore their type and profile..." style="width:100%;background:#12151e;border:1px solid #3b82f6;color:#60a5fa;padding:10px;border-radius:6px;font-size:0.9em;min-height:100px;outline:none;resize:vertical"></textarea>
                </div>

                <div style="margin-bottom:12px">
                    <label style="display:block;margin-bottom:6px;color:#60a5fa;font-size:0.85em">DROP FILES IN (optional — zip, html, py, js, json, anything)</label>
                    <div id="modDropZone" style="border:2px dashed #3b82f6;border-radius:8px;padding:24px;text-align:center;cursor:pointer;color:#3b82f6;font-size:0.85em" onclick="document.getElementById('modFileInput').click()" ondragover="event.preventDefault();this.style.borderColor='#60a5fa'" ondragleave="this.style.borderColor='#3b82f6'" ondrop="handleModDrop(event)">
                        ↑ Tap to add files or drag them here<br>
                        <span style="font-size:0.8em;opacity:0.7">All formats accepted</span>
                    </div>
                    <input id="modFileInput" type="file" multiple style="display:none" onchange="handleModFiles(this.files)"/>
                    <div id="modFileList" style="margin-top:8px;font-size:0.8em;color:#3b82f6"></div>
                </div>

                <div style="margin-bottom:16px">
                    <label style="display:block;margin-bottom:6px;color:#60a5fa;font-size:0.85em">ICON (emoji)</label>
                    <input id="modIcon" type="text" placeholder="🔮" maxlength="2" style="width:80px;background:#12151e;border:1px solid #3b82f6;color:#60a5fa;padding:10px;border-radius:6px;font-size:1.2em;text-align:center;outline:none"/>
                </div>

                <button onclick="buildModule()" style="width:100%;padding:14px;background:linear-gradient(135deg,#1a1a4e,#0d2a4e);border:1px solid #60a5fa;color:#60a5fa;border-radius:8px;font-size:1em;cursor:pointer;letter-spacing:1px">
                    ✦ BUILD MODULE → MY APPS
                </button>
            </div>

            <div class="section" id="modBuildOutput" style="display:none">
                <h2>BUILD LOG</h2>
                <div id="modBuildLog" style="background:#12151e;border:1px solid #3b82f6;padding:12px;border-radius:6px;font-size:0.8em;color:#60a5fa;min-height:60px;white-space:pre-wrap;max-height:200px;overflow-y:auto"></div>
            </div>
        </div>

        <!-- ===== MY APPS TAB ===== -->
        <div id="myapps" class="tab-content">
            <div class="section">
                <h2>⬡ My Apps</h2>
                <p style="color:#3b82f6;margin-bottom:16px;font-size:0.9em">Every module you build lands here. Tap to open. Set a local AI for each one.</p>
                <div style="margin-bottom:12px;display:flex;gap:8px;flex-wrap:wrap">
                    <button onclick="exportAllModules()" style="padding:8px 16px;background:#12151e;border:1px solid #3b82f6;color:#3b82f6;border-radius:6px;font-size:0.8em;cursor:pointer">↓ Export All as ZIP</button>
                    <button onclick="clearAllModules()" style="padding:8px 16px;background:#12151e;border:1px solid #ef4444;color:#ef4444;border-radius:6px;font-size:0.8em;cursor:pointer">✕ Clear All</button>
                </div>
                <div id="myAppsList" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:12px"></div>
                <div id="myAppsEmpty" style="text-align:center;color:#3b82f6;opacity:0.5;padding:40px;font-size:0.9em">
                    No modules yet. Go to ✦ Make Module to build your first one.
                </div>
            </div>

            <!-- Module viewer overlay -->
            <div id="moduleOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:#0c0e14;z-index:1000;flex-direction:column">
                <div style="display:flex;align-items:center;gap:12px;padding:10px 16px;background:#12151e;border-bottom:1px solid #3b82f6;flex-shrink:0">
                    <button onclick="closeModule()" style="background:none;border:1px solid #3b82f6;color:#60a5fa;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:0.85em">← Back</button>
                    <span id="overlayTitle" style="color:#60a5fa;font-weight:bold;flex:1"></span>
                    <select id="overlayAISelect" style="background:#0c0e14;border:1px solid #3b82f6;color:#3b82f6;padding:4px 8px;border-radius:4px;font-size:0.8em" onchange="saveModuleAI()">
                        <option value="">No AI</option>
                        <option value="gemini">Gemini</option>
                        <option value="ollama-llama">Ollama Llama</option>
                        <option value="ollama-mistral">Ollama Mistral</option>
                        <option value="synthAI">SynthAI</option>
                        <option value="cynthia">Cynthia AI</option>
                        <option value="custom">Custom URL</option>
                    </select>
                    <input id="overlayAICustom" type="text" placeholder="http://localhost:11434/..." style="display:none;background:#0c0e14;border:1px solid #3b82f6;color:#60a5fa;padding:4px 8px;border-radius:4px;font-size:0.8em;width:200px"/>
                </div>
                <iframe id="moduleFrame" style="flex:1;width:100%;border:none;background:#fff"></iframe>
            </div>
        </div>

    <script>
    // ========== STATE ==========
    const state = {
        files: [],
        clusters: [],
        selectedFileId: null,
        selectedPreset: null,
        nextFileId: 1,
        nextClusterId: 1,
        graphLayout: 'force',
        pyodide: null,
        pyodideReady: false,
    };

    const CODE_EXTENSIONS = {
        '.js':'javascript','.jsx':'javascript','.ts':'typescript','.tsx':'typescript',
        '.py':'python','.rb':'ruby','.go':'go','.rs':'rust','.java':'java',
        '.c':'c','.cpp':'cpp','.h':'c','.hpp':'cpp','.cs':'csharp',
        '.html':'html','.htm':'html','.css':'css','.scss':'scss','.sass':'sass','.less':'less',
        '.json':'json','.xml':'xml','.yaml':'yaml','.yml':'yaml','.toml':'toml',
        '.md':'markdown','.txt':'text','.sh':'shell','.bash':'shell','.zsh':'shell',
        '.bat':'batch','.ps1':'powershell','.sql':'sql','.graphql':'graphql',
        '.php':'php','.swift':'swift','.kt':'kotlin','.scala':'scala','.lua':'lua',
        '.r':'r','.vue':'vue','.svelte':'svelte','.dart':'dart','.ex':'elixir',
        '.erl':'erlang','.hs':'haskell','.clj':'clojure','.ini':'ini',
        '.cfg':'config','.conf':'config','.env':'env','.proto':'protobuf','.tf':'terraform',
    };

    const STYLE_PRESETS = [
        { id:'standard', name:'Standard', description:'2-space indent, semicolons, double quotes',
          options:{ indentStyle:'spaces', indentSize:2, semicolons:true, quoteStyle:'double', trailingComma:false }},
        { id:'airbnb', name:'Airbnb', description:'2-space indent, semicolons, single quotes, trailing commas',
          options:{ indentStyle:'spaces', indentSize:2, semicolons:true, quoteStyle:'single', trailingComma:true }},
        { id:'prettier', name:'Prettier Default', description:'2-space indent, semicolons, double quotes, trailing commas',
          options:{ indentStyle:'spaces', indentSize:2, semicolons:true, quoteStyle:'double', trailingComma:true }},
        { id:'tabs4', name:'Classic Tabs', description:'Tab indent (4-wide), semicolons, double quotes',
          options:{ indentStyle:'tabs', indentSize:4, semicolons:true, quoteStyle:'double', trailingComma:false }},
        { id:'minimal', name:'Minimal', description:'2-space indent, no semicolons, single quotes',
          options:{ indentStyle:'spaces', indentSize:2, semicolons:false, quoteStyle:'single', trailingComma:false }},
    ];

    // ========== PYODIDE INIT ==========
    async function initPyodide() {
        const statusEl = document.getElementById('pyodideStatus');
        try {
            state.pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/' });
            state.pyodideReady = true;
            statusEl.textContent = 'PYODIDE READY';
            statusEl.className = 'pyodide-status ready';
        } catch(e) {
            statusEl.textContent = 'PYODIDE FAILED - JS-only mode';
            statusEl.className = 'pyodide-status error';
            console.error('Pyodide load error:', e);
        }
    }
    initPyodide();

    // ========== TAB NAVIGATION ==========
    function activateTab(tabId) {
        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        const desktopTab = document.querySelector(`.nav-tab[data-tab="${tabId}"]`);
        if (desktopTab) desktopTab.classList.add('active');
        document.getElementById(tabId).classList.add('active');

        document.querySelectorAll('.mobile-tab-option').forEach(o => o.classList.remove('active'));
        const mobileOpt = document.querySelector(`.mobile-tab-option[data-tab="${tabId}"]`);
        if (mobileOpt) {
            mobileOpt.classList.add('active');
            document.getElementById('mobileTabLabel').textContent = mobileOpt.textContent;
        }
        closeMobileMenu();

        if (tabId === 'graph') setTimeout(() => buildGraph(), 100);
        if (tabId === 'files') renderFileExplorer();
        if (tabId === 'clusters') renderClusters();
        if (tabId === 'style') renderStylePresets();
        if (tabId === 'export') renderExportStats();
        if (tabId === 'causal') setTimeout(() => { if (causalState.nodes.length) renderCausalGraph(); }, 100);
        if (tabId === 'brain') setTimeout(() => renderBrainGraph(), 100);
    }

    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.addEventListener('click', () => activateTab(tab.dataset.tab));
    });

    document.querySelectorAll('.mobile-tab-option').forEach(opt => {
        opt.addEventListener('click', () => activateTab(opt.dataset.tab));
    });

    // ========== FILE UPLOAD ==========
    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');

    uploadZone.addEventListener('click', () => fileInput.click());
    uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); uploadZone.classList.add('dragover'); });
    uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
    uploadZone.addEventListener('drop', (e) => {
        e.preventDefault(); uploadZone.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
    });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

    async function handleFiles(fileList) {
        for (const file of fileList) {
            const lower = file.name.toLowerCase();
            if (lower.endsWith('.zip')) {
                await handleZip(file);
            } else if (lower.endsWith('.pdf')) {
                await handlePdf(file);
            } else if (lower.endsWith('.docx')) {
                await handleDocx(file);
            } else if (lower.endsWith('.tar.gz') || lower.endsWith('.tgz') || lower.endsWith('.tar')) {
                await handleTarGz(file);
            } else {
                await handleSingleFile(file);
            }
        }
        renderUploadedFiles();
    }

    async function handleSingleFile(file) {
        const ext = '.' + file.name.split('.').pop().toLowerCase();
        const lang = CODE_EXTENSIONS[ext] || detectLanguageFromName(file.name);
        try {
            const buffer = await file.arrayBuffer();
            if (!isTextBuffer(new Uint8Array(buffer))) {
                console.warn('Skipping binary file:', file.name);
                return;
            }
            const content = new TextDecoder('utf-8', { fatal: false }).decode(buffer);
            addFile(file.name, file.name, content, lang);
        } catch(e) {
            console.warn('Could not read file:', file.name, e);
        }
    }

    async function handleZip(file) {
        try {
            const data = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(data);
            let count = 0;
            const MAX_FILES = 500;
            const MAX_SIZE = 100 * 1024 * 1024;
            let totalSize = 0;
            for (const [path, entry] of Object.entries(zip.files)) {
                if (entry.dir) continue;
                if (count >= MAX_FILES || totalSize >= MAX_SIZE) break;
                if (shouldSkipPath(path)) continue;
                try {
                    const content = await entry.async('string');
                    if (isTextContent(content)) {
                        const filename = path.split('/').pop();
                        const ext = '.' + filename.split('.').pop().toLowerCase();
                        const lang = CODE_EXTENSIONS[ext] || null;
                        addFile(filename, sanitizePath(path), content, lang);
                        totalSize += content.length;
                        count++;
                    }
                } catch(e) {}
            }
        } catch(e) {
            console.error('ZIP error:', e);
        }
    }

    async function handlePdf(file) {
        if (!state.pyodideReady) {
            alert('PDF parsing requires Pyodide. Please wait for it to load.');
            return;
        }
        try {
            const buffer = await file.arrayBuffer();
            const uint8 = new Uint8Array(buffer);
            state.pyodide.globals.set('pdf_bytes', uint8);
            state.pyodide.globals.set('pdf_name', file.name);
            await state.pyodide.loadPackage('micropip');
            const micropip = state.pyodide.pyimport('micropip');
            await micropip.install('pypdf');
            const result = await state.pyodide.runPythonAsync(`
import io
from pypdf import PdfReader
reader = PdfReader(io.BytesIO(bytes(pdf_bytes)))
text_pages = []
for page in reader.pages:
    t = page.extract_text()
    if t:
        text_pages.append(t)
'\\n\\n--- PAGE BREAK ---\\n\\n'.join(text_pages)
            `);
            if (result && result.trim()) {
                const baseName = file.name.replace(/\.pdf$/i, '');
                addFile(baseName + '_extracted.txt', baseName + '_extracted.txt', result, 'text');
            } else {
                alert('Could not extract text from PDF. It may be image-based.');
            }
        } catch(e) {
            console.error('PDF parse error:', e);
            alert('PDF parsing failed: ' + e.message);
        }
    }

    async function handleDocx(file) {
        try {
            const data = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(data);
            const docXml = await zip.file('word/document.xml')?.async('string');
            if (!docXml) { alert('Could not read DOCX content.'); return; }
            const text = docXml.replace(/<w:p[^>]*>/g, '\n').replace(/<[^>]+>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '"').trim();
            const baseName = file.name.replace(/\.docx?$/i, '');
            addFile(baseName + '_extracted.txt', baseName + '_extracted.txt', text, 'text');
        } catch(e) {
            console.error('DOCX parse error:', e);
            alert('DOCX parsing failed: ' + e.message);
        }
    }

    async function handleTarGz(file) {
        if (!state.pyodideReady) {
            alert('TAR/GZ parsing requires Pyodide. Please wait for it to load.');
            return;
        }
        try {
            const buffer = await file.arrayBuffer();
            const uint8 = new Uint8Array(buffer);
            state.pyodide.globals.set('tar_bytes', uint8);
            const result = await state.pyodide.runPythonAsync(`
import io, tarfile, json
data = bytes(tar_bytes)
mode = 'r:gz' if data[:2] == b'\\x1f\\x8b' else 'r'
try:
    tar = tarfile.open(fileobj=io.BytesIO(data), mode=mode)
except:
    tar = tarfile.open(fileobj=io.BytesIO(data), mode='r')
extracted = []
count = 0
for member in tar.getmembers():
    if member.isdir() or count >= 500:
        continue
    skip = any(s in member.name for s in ['node_modules/', '.git/', '__pycache__/', '.DS_Store'])
    if skip:
        continue
    try:
        f = tar.extractfile(member)
        if f:
            raw = f.read()
            try:
                text = raw.decode('utf-8')
                extracted.append({'name': member.name.split('/')[-1], 'path': member.name, 'content': text})
                count += 1
            except:
                pass
    except:
        pass
json.dumps(extracted)
            `);
            const files = JSON.parse(result);
            for (const f of files) {
                const ext = '.' + f.name.split('.').pop().toLowerCase();
                const lang = CODE_EXTENSIONS[ext] || null;
                addFile(f.name, sanitizePath(f.path), f.content, lang);
            }
        } catch(e) {
            console.error('TAR parse error:', e);
            alert('TAR/GZ parsing failed: ' + e.message);
        }
    }

    function isTextBuffer(uint8) {
        const sample = uint8.subarray(0, Math.min(8192, uint8.length));
        let nullCount = 0;
        for (let i = 0; i < sample.length; i++) {
            if (sample[i] === 0) nullCount++;
        }
        return nullCount / sample.length < 0.01;
    }

    function sanitizePath(p) {
        return p.replace(/\.\.\//g, '').replace(/^\/+/, '').replace(/\/+/g, '/');
    }

    function shouldSkipPath(p) {
        const skip = ['node_modules/', '.git/', '__pycache__/', '.DS_Store', 'thumbs.db', '.env', 'dist/', 'build/', '.next/'];
        return skip.some(s => p.toLowerCase().includes(s.toLowerCase()));
    }

    function isTextContent(content) {
        if (!content || content.length === 0) return false;
        const sample = content.substring(0, 8192);
        let nullCount = 0;
        for (let i = 0; i < sample.length; i++) {
            if (sample.charCodeAt(i) === 0) nullCount++;
        }
        return nullCount / sample.length < 0.01;
    }

    function detectLanguageFromName(name) {
        const lower = name.toLowerCase();
        if (lower === 'makefile') return 'makefile';
        if (lower === 'dockerfile') return 'dockerfile';
        if (lower === '.gitignore') return 'gitignore';
        return null;
    }

    function addFile(filename, path, content, language) {
        const id = state.nextFileId++;
        state.files.push({ id, filename, path, content, language, clusterId: null, size: content.length });
        return id;
    }

    function addPastedCode() {
        const filenameInput = document.getElementById('pasteFilename');
        const langSelect = document.getElementById('pasteLanguage');
        const contentArea = document.getElementById('pasteContent');
        const filename = filenameInput.value.trim() || `snippet_${state.nextFileId}.txt`;
        const content = contentArea.value;
        if (!content.trim()) return;
        let language = langSelect.value;
        if (!language) {
            const ext = '.' + filename.split('.').pop().toLowerCase();
            language = CODE_EXTENSIONS[ext] || autoDetectLanguage(content);
        }
        addFile(filename, filename, content, language);
        filenameInput.value = '';
        contentArea.value = '';
        langSelect.value = '';
        renderUploadedFiles();
    }

    function autoDetectLanguage(content) {
        if (/^\s*<(!DOCTYPE|html|div|span|head|body)/im.test(content)) return 'html';
        if (/^\s*(import|from)\s+\w/m.test(content) && /def\s+\w/m.test(content)) return 'python';
        if (/^\s*(const|let|var|function|import|export)\s/m.test(content)) return 'javascript';
        if (/^\s*(interface|type|enum)\s/m.test(content)) return 'typescript';
        if (/^\s*\{[\s\S]*"[\w]+":/m.test(content)) return 'json';
        if (/^\s*[.#@][\w-]+\s*\{/m.test(content)) return 'css';
        return null;
    }

    function removeFile(id) {
        state.files = state.files.filter(f => f.id !== id);
        if (state.selectedFileId === id) state.selectedFileId = null;
        renderUploadedFiles();
        renderFileExplorer();
    }

    // ========== RENDER FUNCTIONS ==========
    function renderUploadedFiles() {
        const container = document.getElementById('uploadedFilesList');
        document.getElementById('fileCountUpload').textContent = state.files.length;
        if (!state.files.length) {
            container.innerHTML = '<div class="empty-state">No files uploaded yet</div>';
            return;
        }
        container.innerHTML = state.files.map(f => `
            <div class="file-list-item">
                <span class="file-lang">${f.language || '?'}</span>
                <span class="file-name">${escapeHtml(f.path)}</span>
                <span style="color:#3d4555;font-size:0.8em;">${formatSize(f.size)}</span>
                <button class="file-remove-btn" onclick="removeFile(${f.id})">X</button>
            </div>
        `).join('');
    }

    function renderFileExplorer() {
        const container = document.getElementById('fileExplorer');
        document.getElementById('fileCountExplorer').textContent = state.files.length;
        if (!state.files.length) {
            container.innerHTML = '<div class="empty-state">Upload files first</div>';
            return;
        }
        const tree = buildFileTree(state.files);
        container.innerHTML = renderTree(tree, 0);
    }

    function buildFileTree(files) {
        const root = { children: {}, files: [] };
        for (const file of files) {
            const parts = file.path.split('/');
            let current = root;
            for (let i = 0; i < parts.length - 1; i++) {
                if (!current.children[parts[i]]) current.children[parts[i]] = { children: {}, files: [] };
                current = current.children[parts[i]];
            }
            current.files.push(file);
        }
        return root;
    }

    function renderTree(node, depth) {
        let html = '';
        const dirs = Object.keys(node.children).sort();
        for (const dir of dirs) {
            html += `<div style="padding-left:${depth*16}px;padding:4px 0;color:#3b82f6;cursor:default;">
                <span style="color:#93c5fd;">&#x25BC;</span> ${escapeHtml(dir)}/
            </div>`;
            html += renderTree(node.children[dir], depth + 1);
        }
        for (const file of node.files.sort((a,b) => a.filename.localeCompare(b.filename))) {
            const selected = state.selectedFileId === file.id ? ' selected' : '';
            html += `<div class="file-list-item${selected}" style="margin-left:${depth*16}px;" onclick="selectFile(${file.id})">
                <span class="file-lang">${file.language || '?'}</span>
                <span class="file-name">${escapeHtml(file.filename)}</span>
            </div>`;
        }
        return html;
    }

    function selectFile(id) {
        state.selectedFileId = id;
        const file = state.files.find(f => f.id === id);
        if (!file) return;
        document.getElementById('viewerFilename').textContent = file.path;
        const langEl = document.getElementById('viewerLanguage');
        langEl.style.display = file.language ? '' : 'none';
        langEl.textContent = file.language || '';
        const lines = file.content.split('\n');
        document.getElementById('codeContent').innerHTML = lines.map(l =>
            `<span class="code-line">${escapeHtml(l)}</span>`
        ).join('\n');
        renderFileExplorer();
    }

    // ========== DEPENDENCY GRAPH (D3) ==========
    let graphSim = null;
    let graphSvgSel = null;
    let graphZoomBehavior = null;

    function getImports(file) {
        const imports = [];
        if (!file.content) return imports;
        if (file.language === 'javascript' || file.language === 'typescript') {
            const regex = /(?:import\s+.*?from\s+['"]|require\s*\(\s*['"])([^'"]+)['"]/g;
            let m;
            while ((m = regex.exec(file.content)) !== null) imports.push(m[1]);
        } else if (file.language === 'python') {
            const regex = /(?:from\s+(\S+)\s+import|import\s+(\S+))/g;
            let m;
            while ((m = regex.exec(file.content)) !== null) imports.push(m[1] || m[2]);
        } else if (file.language === 'go') {
            const regex = /import\s+(?:\(\s*([\s\S]*?)\)|"([^"]+)")/g;
            let m;
            while ((m = regex.exec(file.content)) !== null) {
                if (m[2]) imports.push(m[2]);
                else if (m[1]) {
                    const inner = m[1].match(/"([^"]+)"/g);
                    if (inner) inner.forEach(i => imports.push(i.replace(/"/g, '')));
                }
            }
        } else if (file.language === 'java' || file.language === 'kotlin') {
            const regex = /import\s+([\w.]+)/g;
            let m;
            while ((m = regex.exec(file.content)) !== null) imports.push(m[1]);
        } else if (file.language === 'rust') {
            const regex = /use\s+([\w:]+)/g;
            let m;
            while ((m = regex.exec(file.content)) !== null) imports.push(m[1]);
        } else if (file.language === 'css' || file.language === 'scss') {
            const regex = /@import\s+['"]([^'"]+)['"]/g;
            let m;
            while ((m = regex.exec(file.content)) !== null) imports.push(m[1]);
        } else if (file.language === 'html') {
            const regex = /(?:src|href)=["']([^"']+\.(?:js|css|ts))["']/g;
            let m;
            while ((m = regex.exec(file.content)) !== null) imports.push(m[1]);
        }
        return imports;
    }

    const LANG_COLORS = {
        javascript:'#f7df1e', typescript:'#3178c6', python:'#3776ab', html:'#e34c26',
        css:'#264de4', json:'#292929', java:'#b07219', go:'#00add8', rust:'#dea584',
        ruby:'#701516', php:'#4f5d95', shell:'#89e051', sql:'#e38c00', markdown:'#083fa1',
        cpp:'#f34b7d', c:'#555555', csharp:'#178600', swift:'#ffac45', kotlin:'#A97BFF',
        scala:'#c22d40', vue:'#41b883', svelte:'#ff3e00', dart:'#00b4ab', elixir:'#6e4a7e',
        default:'#60a5fa'
    };

    function buildGraph() {
        if (!state.files.length) return;
        const container = document.getElementById('graph-container');
        const width = container.clientWidth;
        const height = container.clientHeight || 500;

        const nodes = state.files.map(f => ({
            id: f.id, name: f.filename, path: f.path, language: f.language,
            imports: getImports(f), lines: f.content.split('\n').length, size: f.size,
        }));

        const links = [];
        const fileMap = new Map();
        state.files.forEach(f => {
            fileMap.set(f.filename, f.id);
            fileMap.set(f.path, f.id);
            const noExt = f.filename.replace(/\.[^.]+$/, '');
            fileMap.set(noExt, f.id);
            const pathNoExt = f.path.replace(/\.[^.]+$/, '');
            fileMap.set(pathNoExt, f.id);
        });

        for (const node of nodes) {
            for (const imp of node.imports) {
                const impName = imp.split('/').pop().replace(/\.[^.]+$/, '');
                const candidates = [imp, impName, imp.replace(/^\.\//, ''), imp.replace(/^\.\.\//, '')];
                for (const c of candidates) {
                    if (fileMap.has(c) && fileMap.get(c) !== node.id) {
                        const targetId = fileMap.get(c);
                        if (!links.some(l => l.source === node.id && l.target === targetId)) {
                            links.push({ source: node.id, target: targetId, label: imp });
                        }
                        break;
                    }
                }
            }
        }

        d3.select('#graphSvg').selectAll('*').remove();
        const svg = d3.select('#graphSvg').attr('width', width).attr('height', height);
        const g = svg.append('g');

        graphZoomBehavior = d3.zoom().scaleExtent([0.1, 5]).on('zoom', (e) => g.attr('transform', e.transform));
        svg.call(graphZoomBehavior);
        graphSvgSel = svg;

        svg.append('defs').append('marker')
            .attr('id', 'arrowhead').attr('viewBox', '-0 -5 10 10')
            .attr('refX', 20).attr('refY', 0).attr('orient', 'auto')
            .attr('markerWidth', 8).attr('markerHeight', 8)
            .append('path').attr('d', 'M 0,-5 L 10,0 L 0,5')
            .attr('fill', '#3b82f6');

        const link = g.append('g').selectAll('line').data(links).join('line')
            .attr('class', 'link').attr('stroke', 'rgba(96,165,250,0.25)')
            .attr('stroke-width', 1.5).attr('marker-end', 'url(#arrowhead)');

        const nodeGroup = g.append('g').selectAll('g').data(nodes).join('g')
            .attr('class', 'node').call(d3.drag()
                .on('start', (e, d) => { if (!e.active) graphSim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
                .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
                .on('end', (e, d) => { if (!e.active) graphSim.alphaTarget(0); d.fx = null; d.fy = null; })
            );

        nodeGroup.append('circle')
            .attr('r', d => Math.max(6, Math.min(18, Math.sqrt(d.lines) * 1.5)))
            .attr('fill', d => LANG_COLORS[d.language] || LANG_COLORS.default)
            .attr('stroke', '#0c0e14').attr('stroke-width', 2)
            .attr('filter', 'drop-shadow(0 0 4px rgba(96,165,250,0.4))');

        nodeGroup.append('text')
            .attr('dy', d => Math.max(6, Math.min(18, Math.sqrt(d.lines) * 1.5)) + 14)
            .attr('text-anchor', 'middle')
            .attr('fill', '#93c5fd').attr('font-size', '9px').attr('font-family', 'Courier New')
            .text(d => d.name.length > 20 ? d.name.substring(0, 18) + '..' : d.name);

        const tooltip = document.getElementById('nodeTooltip');
        nodeGroup.on('mouseover', (e, d) => {
            tooltip.style.display = 'block';
            tooltip.style.left = (e.offsetX + 15) + 'px';
            tooltip.style.top = (e.offsetY - 10) + 'px';
            tooltip.innerHTML = `
                <div style="color:#60a5fa;font-weight:bold;margin-bottom:4px;">${escapeHtml(d.path)}</div>
                <div style="color:#3b82f6;">Language: ${d.language || 'unknown'}</div>
                <div style="color:#3b82f6;">Lines: ${d.lines} | Size: ${formatSize(d.size)}</div>
                <div style="color:#3b82f6;">Imports: ${d.imports.length}</div>
                ${d.imports.length ? '<div style="margin-top:4px;color:#93c5fd;">' + d.imports.map(i => '  &rarr; ' + escapeHtml(i)).join('<br>') + '</div>' : ''}
            `;
        }).on('mouseout', () => { tooltip.style.display = 'none'; })
        .on('click', (e, d) => { selectFile(d.id); switchTab('files'); });

        graphSim = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-200))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(25))
            .on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                nodeGroup.attr('transform', d => `translate(${d.x},${d.y})`);
            });

        renderGraphLegend();
    }

    function renderGraphLegend() {
        const langs = new Set(state.files.map(f => f.language).filter(Boolean));
        const legend = document.getElementById('graphLegend');
        legend.innerHTML = '<div style="margin-bottom:6px;color:#60a5fa;font-weight:bold;">Languages</div>' +
            [...langs].map(l => `<div class="legend-item"><div class="legend-dot" style="background:${LANG_COLORS[l] || LANG_COLORS.default};"></div>${l}</div>`).join('');
    }

    function graphZoom(factor) {
        if (!graphSvgSel || !graphZoomBehavior) return;
        graphSvgSel.transition().duration(300).call(graphZoomBehavior.scaleBy, factor);
    }

    function graphReset() {
        if (!graphSvgSel || !graphZoomBehavior) return;
        graphSvgSel.transition().duration(300).call(graphZoomBehavior.transform, d3.zoomIdentity);
    }

    function setGraphLayout(layout) {
        state.graphLayout = layout;
        buildGraph();
    }

    function switchTab(tabId) {
        activateTab(tabId);
    }

    function toggleMobileMenu() {
        const menu = document.getElementById('mobileTabMenu');
        const trigger = document.getElementById('mobileTabTrigger');
        menu.classList.toggle('open');
        trigger.classList.toggle('open');
    }

    function closeMobileMenu() {
        document.getElementById('mobileTabMenu').classList.remove('open');
        document.getElementById('mobileTabTrigger').classList.remove('open');
    }

    // ========== CLUSTERS ==========
    function addCluster() {
        const nameInput = document.getElementById('newClusterName');
        const urlInput = document.getElementById('newClusterUrl');
        const name = nameInput.value.trim();
        const urlPath = urlInput.value.trim() || '/';
        if (!name) return;
        state.clusters.push({ id: state.nextClusterId++, name, urlPath, fileIds: [] });
        nameInput.value = ''; urlInput.value = '';
        renderClusters();
    }

    function removeCluster(id) {
        const cluster = state.clusters.find(c => c.id === id);
        if (cluster) cluster.fileIds.forEach(fid => {
            const f = state.files.find(ff => ff.id === fid);
            if (f) f.clusterId = null;
        });
        state.clusters = state.clusters.filter(c => c.id !== id);
        renderClusters();
    }

    function assignFileToCluster(fileId, clusterId) {
        state.files.forEach(f => { if (f.id === fileId) f.clusterId = clusterId; });
        state.clusters.forEach(c => {
            c.fileIds = c.fileIds.filter(id => id !== fileId);
            if (c.id === clusterId) c.fileIds.push(fileId);
        });
        renderClusters();
    }

    function unassignFile(fileId) {
        const f = state.files.find(ff => ff.id === fileId);
        if (f) f.clusterId = null;
        state.clusters.forEach(c => { c.fileIds = c.fileIds.filter(id => id !== fileId); });
        renderClusters();
    }

    function renderClusters() {
        const container = document.getElementById('clustersList');
        if (!state.clusters.length && !state.files.length) {
            container.innerHTML = '<div class="empty-state">Create clusters to organize your files by page/route</div>';
            document.getElementById('unassignedFilesSection').style.display = 'none';
            return;
        }
        container.innerHTML = state.clusters.map(c => {
            const clusterFiles = state.files.filter(f => f.clusterId === c.id);
            return `<div class="cluster-card">
                <div class="cluster-header">
                    <div>
                        <strong style="color:#60a5fa;font-size:1.1em;">${escapeHtml(c.name)}</strong>
                        <div class="cluster-url">${escapeHtml(c.urlPath)}</div>
                    </div>
                    <button class="danger" onclick="removeCluster(${c.id})" style="margin:0;padding:6px 12px;">Delete</button>
                </div>
                <div class="cluster-files">
                    ${clusterFiles.map(f => `<span class="cluster-file-badge" onclick="unassignFile(${f.id})">${escapeHtml(f.filename)} x</span>`).join('')}
                    ${!clusterFiles.length ? '<span style="color:#3d4555;">No files assigned</span>' : ''}
                </div>
            </div>`;
        }).join('');

        const unassigned = state.files.filter(f => !f.clusterId);
        const section = document.getElementById('unassignedFilesSection');
        if (unassigned.length && state.clusters.length) {
            section.style.display = '';
            document.getElementById('unassignedFiles').innerHTML = unassigned.map(f => `
                <div class="file-list-item">
                    <span class="file-lang">${f.language || '?'}</span>
                    <span class="file-name">${escapeHtml(f.filename)}</span>
                    <select onchange="assignFileToCluster(${f.id}, parseInt(this.value))" style="width:130px;padding:4px;">
                        <option value="">Assign...</option>
                        ${state.clusters.map(c => `<option value="${c.id}">${escapeHtml(c.name)}</option>`).join('')}
                    </select>
                </div>
            `).join('');
        } else {
            section.style.display = 'none';
        }
    }

    // ========== GAP DETECTION ==========
    function runGapDetection() {
        const gaps = detectGaps(state.files);
        renderGaps(gaps);
    }

    function detectGaps(files) {
        const gaps = [];
        const hasFile = (name) => files.some(f => f.filename === name || f.path.endsWith('/' + name));
        const hasExt = (ext) => files.some(f => f.filename.endsWith(ext));
        const hasLang = (lang) => files.some(f => f.language === lang);
        const filePaths = new Set(files.map(f => f.path));

        for (const file of files) {
            if (!file.content) continue;
            if (file.language === 'javascript' || file.language === 'typescript') {
                const regex = /(?:import\s+.*?from\s+['"]|require\s*\(\s*['"])([^'"]+)['"]/g;
                let m;
                while ((m = regex.exec(file.content)) !== null) {
                    const imp = m[1];
                    if (imp.startsWith('.')) {
                        const resolved = resolveImport(file.path, imp);
                        const exts = ['.ts','.tsx','.js','.jsx','.json',''];
                        const found = exts.some(e => filePaths.has(resolved + e) || filePaths.has(resolved + '/index' + e));
                        if (!found) gaps.push({ type:'missing_import', severity:'warning', message:`"${file.filename}" imports "${imp}" but no matching file found` });
                    }
                }
            }
            if (file.language === 'python') {
                const regex = /from\s+(\S+)\s+import/g;
                let m;
                while ((m = regex.exec(file.content)) !== null) {
                    if (m[1].startsWith('.')) {
                        const modFile = m[1].replace(/^\.+/, '').replace(/\./g, '/');
                        if (modFile && !files.some(f => f.path.includes(modFile)))
                            gaps.push({ type:'missing_import', severity:'warning', message:`"${file.filename}" imports from "${m[1]}" but no matching module found` });
                    }
                }
            }
        }

        if ((hasLang('javascript') || hasLang('typescript')) && !hasFile('package.json')) {
            const deps = {};
            const allImps = new Set();
            const builtins = new Set(['fs','path','http','https','crypto','os','child_process','url','util','stream','events','buffer','querystring','net','tls','dns','assert','zlib']);
            for (const file of files) {
                if (file.language !== 'javascript' && file.language !== 'typescript') continue;
                const regex = /(?:import\s+.*?from\s+['"]|require\s*\(\s*['"])([^'"./][^'"]*)['"]/g;
                let m;
                while ((m = regex.exec(file.content)) !== null) {
                    const pkg = m[1].startsWith('@') ? m[1] : m[1].split('/')[0];
                    if (!builtins.has(pkg)) allImps.add(pkg);
                }
            }
            for (const imp of allImps) deps[imp] = '*';
            gaps.push({
                type:'missing_config', severity:'warning', message:'Missing package.json',
                suggestedFile: { filename:'package.json', path:'package.json', content:JSON.stringify({ name:'project', version:'1.0.0', private:true, dependencies:deps }, null, 2), language:'json' }
            });
        }

        if (hasLang('typescript') && !hasFile('tsconfig.json')) {
            gaps.push({
                type:'missing_config', severity:'info', message:'Missing tsconfig.json for TypeScript project',
                suggestedFile: { filename:'tsconfig.json', path:'tsconfig.json', content:JSON.stringify({ compilerOptions:{ target:'ES2020', module:'ESNext', strict:true, jsx:'react-jsx' }, include:['src/**/*'] }, null, 2), language:'json' }
            });
        }

        if (hasLang('python') && !hasFile('requirements.txt') && !hasFile('pyproject.toml')) {
            const pyImps = new Set();
            const stdlibs = new Set(['os','sys','json','re','math','datetime','collections','itertools','functools','typing','pathlib','io','csv','logging','unittest','abc','copy','time','random','string','hashlib','base64','subprocess','threading']);
            for (const file of files) {
                if (file.language !== 'python') continue;
                const regex = /(?:^|\n)\s*(?:import|from)\s+(\w+)/g;
                let m;
                while ((m = regex.exec(file.content)) !== null) if (!stdlibs.has(m[1])) pyImps.add(m[1]);
            }
            if (pyImps.size) {
                gaps.push({
                    type:'missing_config', severity:'warning', message:'Missing requirements.txt',
                    suggestedFile: { filename:'requirements.txt', path:'requirements.txt', content:[...pyImps].sort().join('\n'), language:'text' }
                });
            }
        }

        if ((hasExt('.css') || hasExt('.html')) && !hasFile('.gitignore')) {
            gaps.push({
                type:'missing_config', severity:'info', message:'Missing .gitignore file',
                suggestedFile: { filename:'.gitignore', path:'.gitignore', content:'node_modules/\ndist/\n.env\n*.log\n.DS_Store\n__pycache__/\n*.pyc', language:'text' }
            });
        }

        if (!hasFile('index.html') && (hasExt('.jsx') || hasExt('.tsx'))) {
            gaps.push({
                type:'missing_entry', severity:'info', message:'No index.html found for React/frontend project',
                suggestedFile: { filename:'index.html', path:'index.html', content:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Project</title>\n</head>\n<body>\n  <div id="root"></div>\n  <script type="module" src="/src/main.tsx"><\/script>\n</body>\n</html>', language:'html' }
            });
        }
        return gaps;
    }

    function resolveImport(fromPath, importPath) {
        const fromDir = fromPath.includes('/') ? fromPath.substring(0, fromPath.lastIndexOf('/')) : '';
        const parts = (fromDir ? fromDir + '/' + importPath : importPath).split('/');
        const resolved = [];
        for (const part of parts) {
            if (part === '.' || part === '') continue;
            if (part === '..') resolved.pop();
            else resolved.push(part);
        }
        return resolved.join('/');
    }

    function renderGaps(gaps) {
        const container = document.getElementById('gapResults');
        if (!gaps.length) {
            container.innerHTML = '<div class="section"><div class="empty-state">No gaps detected! Your project looks complete.</div></div>';
            return;
        }
        container.innerHTML = gaps.map((g, i) => `
            <div class="gap-card ${g.severity === 'info' ? 'info' : ''}">
                <span class="gap-severity ${g.severity}">${g.severity.toUpperCase()}</span>
                <div style="margin-top:8px;">${escapeHtml(g.message)}</div>
                ${g.suggestedFile ? `<button onclick="applyGapFix(${i})" style="margin-top:10px;">Add ${escapeHtml(g.suggestedFile.filename)}</button>` : ''}
            </div>
        `).join('');
        container._gaps = gaps;
    }

    function applyGapFix(index) {
        const container = document.getElementById('gapResults');
        const gaps = container._gaps;
        if (!gaps || !gaps[index] || !gaps[index].suggestedFile) return;
        const sf = gaps[index].suggestedFile;
        addFile(sf.filename, sf.path, sf.content, sf.language);
        gaps.splice(index, 1);
        renderGaps(gaps);
        renderUploadedFiles();
    }

    async function runPyodideGapDetection() {
        if (!state.pyodideReady) { alert('Pyodide is still loading. Please wait.'); return; }
        const filesData = state.files.map(f => ({ filename: f.filename, path: f.path, content: f.content, language: f.language }));
        try {
            state.pyodide.globals.set('files_json', JSON.stringify(filesData));
            const result = await state.pyodide.runPythonAsync(`
import json
files = json.loads(files_json)
gaps = []
all_defined = set()
all_referenced = set()
for f in files:
    lang = f.get('language','')
    content = f.get('content','')
    lines = content.split('\\n')
    if lang in ('javascript','typescript'):
        import re
        for line in lines:
            m = re.findall(r'(?:export\\s+(?:default\\s+)?(?:function|class|const|let|var)\\s+)(\\w+)', line)
            all_defined.update(m)
            m2 = re.findall(r'import\\s+.*?from\\s+[\\x27"]([^\\x27"]+)[\\x27"]', line)
            all_referenced.update(m2)
    elif lang == 'python':
        import re
        for line in lines:
            m = re.findall(r'^class\\s+(\\w+)', line)
            all_defined.update(m)
            m2 = re.findall(r'^def\\s+(\\w+)', line)
            all_defined.update(m2)
            m3 = re.findall(r'from\\s+(\\S+)\\s+import', line)
            all_referenced.update(m3)

total_lines = sum(len(f['content'].split('\\n')) for f in files)
lang_counts = {}
for f in files:
    l = f.get('language','unknown') or 'unknown'
    lang_counts[l] = lang_counts.get(l, 0) + 1

result = {
    'total_files': len(files),
    'total_lines': total_lines,
    'languages': lang_counts,
    'symbols_defined': len(all_defined),
    'imports_referenced': len(all_referenced),
    'sample_defined': sorted(list(all_defined))[:20],
    'sample_referenced': sorted(list(all_referenced))[:20],
}
json.dumps(result)
            `);
            const analysis = JSON.parse(result);
            const container = document.getElementById('gapResults');
            container.innerHTML = `
                <div class="section">
                    <h2>Pyodide Deep Analysis</h2>
                    <div class="stats-grid">
                        <div class="stat-card"><div class="stat-value">${analysis.total_files}</div><div class="stat-label">Total Files</div></div>
                        <div class="stat-card"><div class="stat-value">${analysis.total_lines}</div><div class="stat-label">Total Lines</div></div>
                        <div class="stat-card"><div class="stat-value">${analysis.symbols_defined}</div><div class="stat-label">Symbols Defined</div></div>
                        <div class="stat-card"><div class="stat-value">${analysis.imports_referenced}</div><div class="stat-label">Imports Referenced</div></div>
                    </div>
                    <h3>Language Distribution</h3>
                    <div class="stats-grid">
                        ${Object.entries(analysis.languages).map(([l,c]) => `<div class="stat-card"><div class="stat-value">${c}</div><div class="stat-label">${l}</div></div>`).join('')}
                    </div>
                    ${analysis.sample_defined.length ? `<h3>Defined Symbols (sample)</h3><div style="color:#3b82f6;font-size:0.9em;">${analysis.sample_defined.join(', ')}</div>` : ''}
                    ${analysis.sample_referenced.length ? `<h3>Referenced Imports (sample)</h3><div style="color:#3b82f6;font-size:0.9em;">${analysis.sample_referenced.join(', ')}</div>` : ''}
                </div>
            ` + container.innerHTML;
        } catch(e) {
            alert('Pyodide error: ' + e.message);
        }
    }

    // ========== STYLE UNIFORMITY ==========
    function renderStylePresets() {
        const container = document.getElementById('stylePresets');
        container.innerHTML = STYLE_PRESETS.map(p => `
            <div class="preset-card ${state.selectedPreset === p.id ? 'selected' : ''}" onclick="selectPreset('${p.id}')">
                <div class="preset-name">${p.name}</div>
                <div class="preset-desc">${p.description}</div>
            </div>
        `).join('');
    }

    function selectPreset(id) {
        state.selectedPreset = id;
        renderStylePresets();
        const preset = STYLE_PRESETS.find(p => p.id === id);
        if (!preset) return;
        const codeFile = state.files.find(f => f.language === 'javascript' || f.language === 'typescript');
        if (!codeFile) {
            document.getElementById('stylePreviewArea').style.display = 'none';
            return;
        }
        const maxLines = 30;
        const lines = codeFile.content.split('\n');
        const before = lines.slice(0, maxLines).join('\n');
        const after = applyStyle(before, codeFile.language, preset.options);
        document.getElementById('stylePreviewBefore').innerHTML = before.split('\n').map(l => `<span class="code-line">${escapeHtml(l)}</span>`).join('\n');
        document.getElementById('stylePreviewAfter').innerHTML = after.split('\n').map(l => `<span class="code-line">${escapeHtml(l)}</span>`).join('\n');
        document.getElementById('stylePreviewArea').style.display = '';
    }

    function applyStyle(content, language, style) {
        if (!language) return content;
        const codeLangs = ['javascript', 'typescript', 'css', 'json'];
        if (!codeLangs.includes(language)) return content;
        let result = content;
        if (language !== 'json') {
            const lines = result.split('\n');
            result = lines.map(line => {
                const ws = line.match(/^(\s*)/)[1] || '';
                const rest = line.slice(ws.length);
                let count = 0;
                for (const ch of ws) { if (ch === '\t') count += 4; else count += 1; }
                let newIndent;
                if (style.indentStyle === 'tabs') {
                    newIndent = '\t'.repeat(Math.floor(count / style.indentSize)) + ' '.repeat(count % style.indentSize);
                } else {
                    newIndent = ' '.repeat(count);
                }
                return newIndent + rest;
            }).join('\n');
        }
        if (language === 'javascript' || language === 'typescript') {
            if (style.quoteStyle === 'single') {
                result = result.replace(/(?<![\\'])"([^"\\]*(?:\\.[^"\\]*)*)"/g, (match, inner) => inner.includes("'") ? match : `'${inner}'`);
            } else {
                result = result.replace(/(?<![\\"])'([^'\\]*(?:\\.[^'\\]*)*)'/g, (match, inner) => inner.includes('"') ? match : `"${inner}"`);
            }
            result = result.split('\n').map(line => {
                const trimmed = line.trimEnd();
                if (!trimmed || /\/\/|\/\*|\*\//.test(trimmed)) return line;
                const isStmt = /^(\s*)(import|export|const|let|var|return|throw|continue|break|class|function)\b/.test(trimmed) || /^(\s*)[\w$]+\s*[=(]/.test(trimmed) || /\)\s*;?\s*$/.test(trimmed);
                if (!isStmt) return line;
                if (style.semicolons) {
                    if (!trimmed.endsWith(';') && !trimmed.endsWith('{') && !trimmed.endsWith('}') && !trimmed.endsWith(',') && !trimmed.endsWith('(') && !trimmed.endsWith('=>'))
                        return trimmed + ';';
                } else {
                    if (trimmed.endsWith(';')) return trimmed.slice(0, -1);
                }
                return line;
            }).join('\n');
        }
        return result;
    }

    function applyStyleToAll() {
        if (!state.selectedPreset) return;
        const preset = STYLE_PRESETS.find(p => p.id === state.selectedPreset);
        if (!preset) return;
        let changed = 0;
        for (const file of state.files) {
            const newContent = applyStyle(file.content, file.language, preset.options);
            if (newContent !== file.content) { file.content = newContent; changed++; }
        }
        alert(`Style applied to ${changed} file(s).`);
    }

    // ========== LIVE PREVIEW ==========
    function runPreview() {
        const htmlFile = state.files.find(f => f.filename === 'index.html' || f.path.endsWith('/index.html'));
        const cssFiles = state.files.filter(f => f.language === 'css');
        const jsFiles = state.files.filter(f => f.language === 'javascript');

        let html = htmlFile?.content || `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Preview</title></head><body><div id="root"></div></body></html>`;
        const cssBlock = cssFiles.map(f => `/* ${f.filename} */\n${f.content}`).join('\n\n');
        const jsBlock = jsFiles.map(f => `// ${f.filename}\n${f.content}`).join('\n\n');

        if (cssBlock && !html.includes('<style')) {
            html = html.replace('</head>', `<style>\n${cssBlock}\n</style>\n</head>`);
        }

        const consoleScript = `<script>
            const _origConsole = { log: console.log, warn: console.warn, error: console.error };
            ['log','warn','error'].forEach(m => {
                console[m] = function(...args) {
                    _origConsole[m](...args);
                    parent.postMessage({ type:'console', method:m, args: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)) }, '*');
                };
            });
            window.onerror = (msg, src, line) => parent.postMessage({ type:'console', method:'error', args:['Error: ' + msg + ' (line ' + line + ')'] }, '*');
        <\/script>`;

        if (jsBlock && !html.includes(jsBlock)) {
            html = html.replace('</body>', `<script>\n${jsBlock}\n<\/script>\n</body>`);
        }
        html = html.replace('<head>', '<head>\n' + consoleScript);

        const blob = new Blob([html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        document.getElementById('previewFrame').src = url;
        document.getElementById('previewConsole').innerHTML = '<div style="color:#3b82f6;">Console output:</div>';
    }

    window.addEventListener('message', (e) => {
        if (e.data?.type === 'console') {
            const container = document.getElementById('previewConsole');
            const cls = 'console-' + e.data.method;
            container.innerHTML += `<div class="${cls}">[${e.data.method}] ${escapeHtml(e.data.args.join(' '))}</div>`;
            container.scrollTop = container.scrollHeight;
        }
    });

    function setViewport(btn, width) {
        document.querySelectorAll('.viewport-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const frame = document.getElementById('previewFrame');
        frame.style.width = width;
        frame.style.margin = width === '100%' ? '0' : '0 auto';
        frame.style.display = 'block';
    }

    // ========== PYTHON CONSOLE ==========
    async function runPython() {
        if (!state.pyodideReady) { alert('Pyodide is still loading.'); return; }
        const code = document.getElementById('pythonCode').value;
        const outputEl = document.getElementById('pythonOutput');
        outputEl.innerHTML = '<span style="color:#f59e0b;">Running...</span>';
        try {
            const filesData = state.files.map(f => ({ filename: f.filename, path: f.path, content: f.content, language: f.language }));
            state.pyodide.globals.set('files_json', JSON.stringify(filesData));
            await state.pyodide.runPythonAsync('import json; files = json.loads(files_json)');

            state.pyodide.setStdout({ batched: (text) => { outputEl.innerHTML += escapeHtml(text) + '\n'; }});
            state.pyodide.setStderr({ batched: (text) => { outputEl.innerHTML += `<span class="error-output">${escapeHtml(text)}</span>\n`; }});
            outputEl.innerHTML = '';
            await state.pyodide.runPythonAsync(code);
            if (!outputEl.innerHTML.trim()) outputEl.innerHTML = '<span style="color:#3b82f6;">(no output)</span>';
        } catch(e) {
            outputEl.innerHTML += `<span class="error-output">${escapeHtml(e.message)}</span>`;
        }
    }

    function clearPythonOutput() {
        document.getElementById('pythonOutput').innerHTML = 'Waiting for execution...';
    }

    // ========== EXPORT ==========
    function renderExportStats() {
        const totalLines = state.files.reduce((s, f) => s + f.content.split('\n').length, 0);
        const totalSize = state.files.reduce((s, f) => s + f.size, 0);
        const langs = new Set(state.files.map(f => f.language).filter(Boolean));
        document.getElementById('exportStats').innerHTML = `
            <div class="stat-card"><div class="stat-value">${state.files.length}</div><div class="stat-label">Files</div></div>
            <div class="stat-card"><div class="stat-value">${totalLines}</div><div class="stat-label">Lines of Code</div></div>
            <div class="stat-card"><div class="stat-value">${formatSize(totalSize)}</div><div class="stat-label">Total Size</div></div>
            <div class="stat-card"><div class="stat-value">${langs.size}</div><div class="stat-label">Languages</div></div>
            <div class="stat-card"><div class="stat-value">${state.clusters.length}</div><div class="stat-label">Clusters</div></div>
        `;
    }

    async function exportZip() {
        if (!state.files.length) { alert('No files to export.'); return; }
        const zip = new JSZip();
        for (const file of state.files) {
            zip.file(file.path, file.content);
        }
        const blob = await zip.generateAsync({ type: 'blob' });
        downloadBlob(blob, 'project_export.zip');
    }

    function exportHtml() {
        if (!state.files.length) { alert('No files to export.'); return; }
        const clusterMap = new Map(state.clusters.map(c => [c.id, c]));
        const unclustered = state.files.filter(f => !f.clusterId);
        const clusteredGroups = new Map();
        for (const file of state.files) {
            if (file.clusterId) {
                if (!clusteredGroups.has(file.clusterId)) clusteredGroups.set(file.clusterId, []);
                clusteredGroups.get(file.clusterId).push(file);
            }
        }
        let navItems = '';
        let contentSections = '';
        let sectionIndex = 0;
        for (const [clusterId, clusterFiles] of clusteredGroups) {
            const cluster = clusterMap.get(clusterId);
            if (!cluster) continue;
            navItems += `<a href="#section-${sectionIndex}" style="display:block;padding:8px 16px;color:#60a5fa;text-decoration:none;border-left:3px solid transparent;" onmouseover="this.style.borderLeftColor='#60a5fa'" onmouseout="this.style.borderLeftColor='transparent'">${escapeHtml(cluster.name)} <small style="color:#3b82f6;">${escapeHtml(cluster.urlPath)}</small></a>`;
            contentSections += `<div id="section-${sectionIndex}" style="margin-bottom:30px;"><h2 style="color:#60a5fa;border-bottom:1px solid #3b82f6;padding-bottom:8px;">${escapeHtml(cluster.name)} - ${escapeHtml(cluster.urlPath)}</h2>`;
            for (const f of clusterFiles) {
                contentSections += `<div style="margin:15px 0;"><h3 style="color:#93c5fd;">${escapeHtml(f.path)}</h3><pre style="background:#12151e;border:1px solid #3b82f6;padding:12px;overflow-x:auto;font-size:0.85em;">${escapeHtml(f.content)}</pre></div>`;
            }
            contentSections += '</div>';
            sectionIndex++;
        }
        if (unclustered.length) {
            navItems += `<a href="#section-unclustered" style="display:block;padding:8px 16px;color:#3b82f6;text-decoration:none;">Unclustered</a>`;
            contentSections += `<div id="section-unclustered" style="margin-bottom:30px;"><h2 style="color:#3b82f6;border-bottom:1px solid #2a3040;padding-bottom:8px;">Unclustered Files</h2>`;
            for (const f of unclustered) {
                contentSections += `<div style="margin:15px 0;"><h3 style="color:#93c5fd;">${escapeHtml(f.path)}</h3><pre style="background:#12151e;border:1px solid #3b82f6;padding:12px;overflow-x:auto;font-size:0.85em;">${escapeHtml(f.content)}</pre></div>`;
            }
            contentSections += '</div>';
        }
        const html = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>Project Export</title><style>*{margin:0;padding:0;box-sizing:border-box;}body{font-family:'Courier New',monospace;background:#0c0e14;color:#60a5fa;display:flex;height:100vh;}.sidebar{width:260px;background:#12151e;border-right:2px solid #3b82f6;overflow-y:auto;padding:15px 0;flex-shrink:0;}.sidebar h1{padding:15px;font-size:1.2em;border-bottom:1px solid #3b82f6;}.main{flex:1;overflow-y:auto;padding:30px;}pre{white-space:pre-wrap;word-wrap:break-word;}@media(max-width:768px){.sidebar{display:none;}.main{padding:15px;}}</style></head><body><div class="sidebar"><h1>Project Files</h1>${navItems}</div><div class="main">${contentSections}</div></body></html>`;
        const blob = new Blob([html], { type: 'text/html' });
        downloadBlob(blob, 'project_export.html');
    }

    function exportDependencyReport() {
        if (!state.files.length) { alert('No files to analyze.'); return; }
        const nodes = state.files.map(f => ({ id: f.id, filename: f.filename, path: f.path, language: f.language, lines: f.content.split('\n').length, imports: getImports(f) }));
        const edges = [];
        const fileMap = new Map();
        state.files.forEach(f => { fileMap.set(f.filename, f.id); fileMap.set(f.path, f.id); });
        for (const n of nodes) {
            for (const imp of n.imports) {
                const name = imp.split('/').pop().replace(/\.[^.]+$/, '');
                if (fileMap.has(name)) edges.push({ from: n.id, to: fileMap.get(name), import: imp });
                else if (fileMap.has(imp)) edges.push({ from: n.id, to: fileMap.get(imp), import: imp });
            }
        }
        const report = { generated: new Date().toISOString(), totalFiles: state.files.length, nodes, edges, clusters: state.clusters };
        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        downloadBlob(blob, 'dependency_report.json');
    }

    // ========== UTILITIES ==========
    function escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // ========== CAUSAL ENGINE ==========
    const CAUSAL_LAYERS = [
        { key:'planetary', name:'Planetary', category:'Primal Source', color:'#ff6600', physicalAnalogue:'Gravitational/Magnetic Field', keynote:'Conscious Body', layerIndex:0 },
        { key:'dimension', name:'Dimension', category:'Quantum State', color:'#60a5fa', physicalAnalogue:'Field Container / Energy Pool', keynote:'Being/Evolution/Movement/Design', layerIndex:1 },
        { key:'gate', name:'Gate', category:'Symbolic Layer', color:'#38bdf8', physicalAnalogue:'Genetic Codon Verb', keynote:'64 Archetypes', layerIndex:2 },
        { key:'line', name:'Line', category:'Symbolic Layer', color:'#0099cc', physicalAnalogue:'Stable/Unstable State', keynote:'384 Expressions', layerIndex:3 },
        { key:'color', name:'Color', category:'Dimensional Filter', color:'#ffcc00', physicalAnalogue:'Motivational Pressure', keynote:'6 Fields', layerIndex:4 },
        { key:'tone', name:'Tone', category:'Dimensional Filter', color:'#f59e0b', physicalAnalogue:'Harmonic Frequency Mode', keynote:'6 Frequencies', layerIndex:5 },
        { key:'base', name:'Base', category:'Dimensional Filter', color:'#ff8800', physicalAnalogue:'Primal Subatomic Substrate', keynote:'5 Substrates', layerIndex:6 },
        { key:'degree', name:'Degree', category:'Source Coordinate', color:'#ff3366', physicalAnalogue:'Phase-Space Trajectory', keynote:'Arc Position', layerIndex:7 },
        { key:'minute', name:'Minute', category:'Source Coordinate', color:'#f9a8d4', physicalAnalogue:'Sub-Arc Precision', keynote:'Fine Tuning', layerIndex:8 },
        { key:'second', name:'Second', category:'Source Coordinate', color:'#ff99aa', physicalAnalogue:'Exact Coordinate', keynote:'Pinpoint Phase', layerIndex:9 },
        { key:'axis', name:'Axis', category:'Polarity Anchor', color:'#ff0044', physicalAnalogue:'Dualistic Attractor', keynote:'Polarity Tension', layerIndex:10 },
        { key:'zodiac', name:'Zodiac', category:'Field Geometry', color:'#cc33ff', physicalAnalogue:'Archetypal Subject Field', keynote:'12 Arcs', layerIndex:11 },
        { key:'house', name:'House', category:'Field Geometry', color:'#9933cc', physicalAnalogue:'Contextual Domain', keynote:'12 Domains', layerIndex:12 },
    ];

    const CAUSAL_DIMENSIONS = [
        { key:'Being', name:'Being Field', keynote:'I Am (Survival/Sensation)', physicalAnalogue:'Matter / Genetics' },
        { key:'Evolution', name:'Evolution Field', keynote:'I Remember (Integration/Role)', physicalAnalogue:'Mind / Recurrence' },
        { key:'Movement', name:'Movement Field', keynote:'I Define (Activity/Measure)', physicalAnalogue:'Individuality / Energy' },
        { key:'Design', name:'Design Field', keynote:'I Design (Continuity/Structure)', physicalAnalogue:'Ego / Structure' },
        { key:'Space', name:'Space Field (Emergent)', keynote:'Personality (The Hologram)', physicalAnalogue:'Emergent Form / Interference Pattern' },
    ];

    const CAUSAL_OPERATORS = [
        { symbol:'x(t)', name:'State Vector', function:'9-Point Consciousness State', definition:'The current state of all dimensional fields' },
        { symbol:'O(t)', name:'Master Operator', function:'Total Physics (Governing Evolution)', definition:'Derived from C, E, D planes; evolves the state' },
        { symbol:'\u03C3()', name:'Non-Linearity', function:'Saturation / Stability Constraint', definition:'Prevents runaway; enforces bounded evolution' },
        { symbol:'R(t)', name:'Resonance Field', function:'Weighted Triadic Feedback Loop', definition:'Causal resonance from prior states' },
        { symbol:'\u00B7', name:'Singularity', function:'Pre-collapse Seed', definition:'Uniform Superposition / Initial Potential' },
        { symbol:'\u25CB', name:'Collapse', function:'Anchor Coordinate', definition:'Dimensional Fixation / Measurement' },
        { symbol:'=', name:'Mirror', function:'Revelation', definition:'Unification of Duals' },
        { symbol:'\u2192', name:'Vector', function:'Measurement Direction', definition:'Transformation / Query Direction' },
        { symbol:'\u2014', name:'Current', function:'Being Continuity', definition:'Sustained Existence / Flow' },
    ];

    const CAUSAL_EDGES_LAW = [
        { from:'planetary', to:'zodiac', law:'Law of Field Assignment', desc:'Planet is placed within a Zodiac arc' },
        { from:'planetary', to:'house', law:'Law of Domain Placement', desc:'Planet occupies a House domain' },
        { from:'zodiac', to:'degree', law:'Law of Time/Location', desc:'Zodiac arc sets the degree coordinate' },
        { from:'degree', to:'minute', law:'Law of Sub-Arc Precision', desc:'Degree resolves to minute' },
        { from:'minute', to:'second', law:'Law of Exact Phase', desc:'Minute resolves to second' },
        { from:'degree', to:'gate', law:'Law of Arc Projection', desc:'DMS projects onto 64 fractional arcs' },
        { from:'gate', to:'line', law:'Law of Expression', desc:'Gate resolves to 1 of 6 Lines' },
        { from:'degree', to:'color', law:'Law of Emanation', desc:'DMS sub-arcs set Color value' },
        { from:'degree', to:'tone', law:'Law of Emanation', desc:'DMS sub-arcs set Tone value' },
        { from:'degree', to:'base', law:'Law of Emanation', desc:'DMS sub-arcs set Base value' },
        { from:'color', to:'dimension', law:'Law of Field Structuring', desc:'Color structures dimensional amplitudes' },
        { from:'tone', to:'dimension', law:'Law of Field Structuring', desc:'Tone structures dimensional phases' },
        { from:'base', to:'dimension', law:'Law of Field Structuring', desc:'Base structures primal substrate' },
        { from:'line', to:'dimension', law:'Law of Field Structuring', desc:'Line expression shapes field state' },
        { from:'axis', to:'dimension', law:'Law of Polarity', desc:'Axis enforces inverse tension between fields' },
    ];

    const causalState = {
        nodes: [],
        edges: [],
        nextId: 1,
        selectedNode: null,
        simTime: 0,
        simRunning: false,
        simInterval: null,
        stateVector: new Array(9).fill(0),
        masterMatrix: [],
        resonance: new Array(9).fill(0),
    };

    function causalInit() {
        renderCausalPalette();
        renderCausalOperators();
        initSimReadout();
    }

    function renderCausalPalette() {
        const palette = document.getElementById('causalPalette');
        const categories = {};
        CAUSAL_LAYERS.forEach(l => {
            if (!categories[l.category]) categories[l.category] = [];
            categories[l.category].push(l);
        });
        let html = '';
        for (const [cat, layers] of Object.entries(categories)) {
            html += `<div class="palette-category"><div class="palette-category-title">${cat}</div>`;
            for (const l of layers) {
                html += `<button class="palette-node-btn" onclick="causalAddNode('${l.key}')"><span class="node-dot" style="background:${l.color};"></span>${l.name}</button>`;
            }
            html += '</div>';
        }
        palette.innerHTML = html;
    }

    function renderCausalOperators() {
        const container = document.getElementById('causalOperators');
        container.innerHTML = CAUSAL_OPERATORS.map(op =>
            `<span class="operator-badge" title="${op.definition}">${op.symbol} ${op.name}</span>`
        ).join('');
    }

    function causalAddNode(layerKey, customLabel, x, y) {
        const layer = CAUSAL_LAYERS.find(l => l.key === layerKey);
        if (!layer) return null;
        const id = causalState.nextId++;
        let label = customLabel || layer.name;
        if (layerKey === 'dimension') {
            const dimCount = causalState.nodes.filter(n => n.layerKey === 'dimension').length;
            const dims = ['Being','Evolution','Movement','Design','Space'];
            label = dims[dimCount % dims.length] + ' Field';
        }
        const node = {
            id, layerKey, label, category: layer.category, color: layer.color,
            physicalAnalogue: layer.physicalAnalogue, keynote: layer.keynote,
            x: x || 100 + Math.random() * 400, y: y || 100 + Math.random() * 300,
            amplitude: 0.5 + Math.random() * 0.5,
            phase: Math.random() * Math.PI * 2,
            value: Math.random(),
        };
        causalState.nodes.push(node);
        autoConnectEdges(node);
        renderCausalGraph();
        return node;
    }

    function autoConnectEdges(newNode) {
        for (const rule of CAUSAL_EDGES_LAW) {
            if (rule.to === newNode.layerKey) {
                const sources = causalState.nodes.filter(n => n.layerKey === rule.from);
                for (const src of sources) {
                    if (!causalState.edges.some(e => e.sourceId === src.id && e.targetId === newNode.id)) {
                        causalState.edges.push({ sourceId: src.id, targetId: newNode.id, law: rule.law, desc: rule.desc });
                    }
                }
            }
            if (rule.from === newNode.layerKey) {
                const targets = causalState.nodes.filter(n => n.layerKey === rule.to);
                for (const tgt of targets) {
                    if (!causalState.edges.some(e => e.sourceId === newNode.id && e.targetId === tgt.id)) {
                        causalState.edges.push({ sourceId: newNode.id, targetId: tgt.id, law: rule.law, desc: rule.desc });
                    }
                }
            }
        }
    }

    function causalClear() {
        causalState.nodes = [];
        causalState.edges = [];
        causalState.nextId = 1;
        causalState.selectedNode = null;
        causalState.simTime = 0;
        causalState.stateVector = new Array(9).fill(0);
        causalState.resonance = new Array(9).fill(0);
        renderCausalGraph();
        initSimReadout();
        document.getElementById('causalInfoPanel').innerHTML = '<h4>Select a node for details</h4>';
    }

    function causalLoadCanonical() {
        causalClear();
        const W = document.getElementById('causalGraphContainer').clientWidth || 900;
        const H = document.getElementById('causalGraphContainer').clientHeight || 500;
        const layerX = {};
        const cols = CAUSAL_LAYERS.length;
        CAUSAL_LAYERS.forEach((l, i) => { layerX[l.key] = 60 + (i / (cols - 1)) * (W - 120); });
        const nodesPerLayer = {};

        const canonicalNodes = [
            { key:'planetary', label:'Conscious Sun' },
            { key:'dimension', label:'Being Field', dimIdx:0 },
            { key:'dimension', label:'Evolution Field', dimIdx:1 },
            { key:'dimension', label:'Movement Field', dimIdx:2 },
            { key:'dimension', label:'Design Field', dimIdx:3 },
            { key:'dimension', label:'Space Field', dimIdx:4 },
            { key:'gate', label:'Gate (Codon)' },
            { key:'line', label:'Line (Expr)' },
            { key:'color', label:'Color (Motive)' },
            { key:'tone', label:'Tone (Freq)' },
            { key:'base', label:'Base (Substrate)' },
            { key:'degree', label:'Degree\u00B0' },
            { key:'minute', label:"Minute'" },
            { key:'second', label:'Second"' },
            { key:'axis', label:'Sun/Earth Axis' },
            { key:'zodiac', label:'Zodiac Arc' },
            { key:'house', label:'House Domain' },
        ];

        for (const cn of canonicalNodes) {
            if (!nodesPerLayer[cn.key]) nodesPerLayer[cn.key] = 0;
            nodesPerLayer[cn.key]++;
            const count = causalState.nodes.filter(n => n.layerKey === cn.key).length;
            const total = canonicalNodes.filter(c => c.key === cn.key).length;
            const ySpacing = H / (total + 1);
            const x = layerX[cn.key];
            const y = ySpacing * (count + 1);
            causalAddNode(cn.key, cn.label, x, y);
        }

        initStateFromGraph();
        renderCausalGraph();
        updateSimReadout();
    }

    function convertFilesToCausal() {
        if (state.files.length === 0) {
            alert('No files uploaded yet. Upload some code files first, then convert them to a causal graph.');
            return;
        }

        causalClear();
        const W = document.getElementById('causalGraphContainer').clientWidth || 900;
        const H = document.getElementById('causalGraphContainer').clientHeight || 500;

        const fileAnalysis = state.files.map(f => {
            const ext = (f.name.split('.').pop() || '').toLowerCase();
            const lines = (f.content || '').split('\n');
            const lineCount = lines.length;
            const imports = lines.filter(l => /^(import |require\(|from |#include|use |using )/.test(l.trim()));
            const exports = lines.filter(l => /^(export |module\.exports|pub |public )/.test(l.trim()));
            const funcs = lines.filter(l => /^\s*(function |def |fn |func |const \w+ = |class )/.test(l));
            const complexity = Math.min(1, lineCount / 500);
            const isEntry = /^(index|main|app|server|entry)\./i.test(f.name);
            const isConfig = /^(package\.json|tsconfig|\.env|config|webpack|vite\.config)/i.test(f.name);
            const isStyle = /\.(css|scss|sass|less|styl)$/i.test(f.name);
            const isTest = /\.(test|spec)\./i.test(f.name);
            const isComponent = /\.(jsx|tsx|vue|svelte)$/i.test(f.name) || /^[A-Z]/.test(f.name.split('/').pop());

            let layerMapping = 'line';
            if (isEntry) layerMapping = 'gate';
            else if (isConfig) layerMapping = 'base';
            else if (isStyle) layerMapping = 'color';
            else if (isTest) layerMapping = 'axis';
            else if (isComponent) layerMapping = 'gate';
            else if (ext === 'html') layerMapping = 'house';
            else if (['ts','js','py','go','rs','java','cpp','c','rb','php'].includes(ext)) layerMapping = 'gate';
            else if (ext === 'json' || ext === 'yaml' || ext === 'yml' || ext === 'toml') layerMapping = 'degree';
            else if (ext === 'md' || ext === 'txt') layerMapping = 'zodiac';

            return {
                file: f, ext, lineCount, imports, exports, funcs,
                complexity, isEntry, isConfig, isStyle, isTest, isComponent,
                layerMapping
            };
        });

        const planetaryNode = causalAddNode('planetary', 'Project Root', W * 0.08, H * 0.5);

        const dimLabels = ['Being','Evolution','Movement','Design','Space'];
        const dimNodes = [];
        for (let i = 0; i < 5; i++) {
            const dn = causalAddNode('dimension', dimLabels[i] + ' Field', W * 0.18, H * 0.15 + i * (H * 0.16));
            dimNodes.push(dn);
        }

        const layerGroups = {};
        for (const fa of fileAnalysis) {
            if (!layerGroups[fa.layerMapping]) layerGroups[fa.layerMapping] = [];
            layerGroups[fa.layerMapping].push(fa);
        }

        const fileNodes = [];
        const layerOrder = ['gate','line','color','tone','base','degree','minute','second','axis','zodiac','house'];
        let globalIdx = 0;

        for (const layerKey of layerOrder) {
            const group = layerGroups[layerKey] || [];
            const layerDef = CAUSAL_LAYERS.find(l => l.key === layerKey);
            if (!layerDef) continue;
            const colX = 0.3 + (layerDef.layerIndex / 13) * 0.6;

            for (let gi = 0; gi < group.length; gi++) {
                const fa = group[gi];
                const shortName = fa.file.name.split('/').pop();
                const label = shortName.length > 20 ? shortName.substring(0, 18) + '..' : shortName;
                const yPos = H * 0.08 + ((gi + 0.5) / Math.max(group.length, 1)) * H * 0.84;
                const node = causalAddNode(layerKey, label, W * colX, yPos);
                if (node) {
                    node.fileId = fa.file.id;
                    node.fileName = fa.file.name;
                    node.value = 0.2 + fa.complexity * 0.6;
                    node.amplitude = 0.3 + (fa.funcs.length / Math.max(fa.lineCount, 1)) * 2;
                    node.amplitude = Math.min(1, node.amplitude);

                    if (fa.isEntry) {
                        node.value = 0.9;
                        node.amplitude = 0.95;
                    }

                    fileNodes.push({ node, analysis: fa });
                    globalIdx++;
                }
            }
        }

        for (let i = 0; i < fileNodes.length; i++) {
            const fnA = fileNodes[i];
            for (let j = i + 1; j < fileNodes.length; j++) {
                const fnB = fileNodes[j];
                const aImportsB = fnA.analysis.imports.some(imp => {
                    const impText = imp.toLowerCase();
                    const bBase = fnB.analysis.file.name.replace(/\.[^.]+$/, '').split('/').pop().toLowerCase();
                    return impText.includes(bBase);
                });
                const bImportsA = fnB.analysis.imports.some(imp => {
                    const impText = imp.toLowerCase();
                    const aBase = fnA.analysis.file.name.replace(/\.[^.]+$/, '').split('/').pop().toLowerCase();
                    return impText.includes(aBase);
                });
                if (aImportsB) {
                    causalState.edges.push({
                        sourceId: fnA.node.id, targetId: fnB.node.id,
                        law: 'Law of Import Dependency', desc: fnA.analysis.file.name + ' imports ' + fnB.analysis.file.name
                    });
                }
                if (bImportsA) {
                    causalState.edges.push({
                        sourceId: fnB.node.id, targetId: fnA.node.id,
                        law: 'Law of Import Dependency', desc: fnB.analysis.file.name + ' imports ' + fnA.analysis.file.name
                    });
                }
            }
        }

        const entryNodes = fileNodes.filter(fn => fn.analysis.isEntry);
        const configNodes = fileNodes.filter(fn => fn.analysis.isConfig);
        const styleNodes = fileNodes.filter(fn => fn.analysis.isStyle);
        const testNodes = fileNodes.filter(fn => fn.analysis.isTest);
        const componentNodes = fileNodes.filter(fn => fn.analysis.isComponent);

        for (const en of entryNodes) {
            causalState.edges.push({ sourceId: planetaryNode.id, targetId: en.node.id, law: 'Law of Field Assignment', desc: 'Project root activates entry point' });
        }
        if (entryNodes.length === 0 && fileNodes.length > 0) {
            causalState.edges.push({ sourceId: planetaryNode.id, targetId: fileNodes[0].node.id, law: 'Law of Field Assignment', desc: 'Project root connects to first file' });
        }

        for (const cn of configNodes) {
            for (const fn of fileNodes) {
                if (fn !== cn && !fn.analysis.isConfig) {
                    causalState.edges.push({ sourceId: cn.node.id, targetId: fn.node.id, law: 'Law of Emanation', desc: cn.analysis.file.name + ' configures ' + fn.analysis.file.name });
                }
            }
        }

        for (const sn of styleNodes) {
            for (const comp of componentNodes) {
                causalState.edges.push({ sourceId: sn.node.id, targetId: comp.node.id, law: 'Law of Field Structuring', desc: sn.analysis.file.name + ' styles ' + comp.analysis.file.name });
            }
        }

        for (const tn of testNodes) {
            for (const fn of fileNodes) {
                if (fn !== tn && !fn.analysis.isTest) {
                    const testBase = tn.analysis.file.name.replace(/\.(test|spec)\./, '.').replace(/\.[^.]+$/, '').split('/').pop().toLowerCase();
                    const fnBase = fn.analysis.file.name.replace(/\.[^.]+$/, '').split('/').pop().toLowerCase();
                    if (testBase === fnBase) {
                        causalState.edges.push({ sourceId: tn.node.id, targetId: fn.node.id, law: 'Law of Polarity', desc: tn.analysis.file.name + ' tests ' + fn.analysis.file.name });
                    }
                }
            }
        }

        for (const fn of fileNodes) {
            const dimIdx = fn.analysis.isEntry ? 0 : fn.analysis.isComponent ? 1 : fn.analysis.isStyle ? 2 : fn.analysis.isConfig ? 3 : 4;
            if (dimNodes[dimIdx]) {
                causalState.edges.push({
                    sourceId: fn.node.id, targetId: dimNodes[dimIdx].id,
                    law: 'Law of Field Structuring',
                    desc: fn.analysis.file.name + ' feeds ' + dimLabels[dimIdx] + ' field'
                });
            }
        }

        initStateFromGraph();

        for (const fn of fileNodes) {
            const idx = fileNodes.indexOf(fn);
            causalState.stateVector[idx % 9] += fn.node.value * 0.1;
        }
        normalizeState();

        renderCausalGraph();
        updateSimReadout();
    }

    function initStateFromGraph() {
        const dimNodes = causalState.nodes.filter(n => n.layerKey === 'dimension');
        causalState.stateVector = new Array(9).fill(0);
        for (let i = 0; i < Math.min(dimNodes.length, 5); i++) {
            const dimDef = CAUSAL_DIMENSIONS[i];
            if (dimDef) {
                dimNodes[i].dimensionKey = dimDef.key;
                dimNodes[i].dimensionKeynote = dimDef.keynote;
                dimNodes[i].dimensionPhysical = dimDef.physicalAnalogue;
            }
            causalState.stateVector[i] = dimNodes[i].value;
        }
        for (let i = 5; i < 9; i++) {
            causalState.stateVector[i] = 0.1 + Math.random() * 0.3;
        }
        normalizeState();
        buildMasterMatrix();
    }

    function normalizeState() {
        let sum = causalState.stateVector.reduce((a, b) => a + Math.abs(b), 0);
        if (sum > 0) causalState.stateVector = causalState.stateVector.map(v => v / sum);
    }

    function getLayerValue(layerKey) {
        const nodes = causalState.nodes.filter(n => n.layerKey === layerKey);
        if (!nodes.length) return 0;
        return nodes.reduce((s, n) => s + n.value * n.amplitude, 0) / nodes.length;
    }

    function buildMasterMatrix() {
        const N = 9;
        const M = 13;
        causalState.masterMatrix = [];

        const layerValues = CAUSAL_LAYERS.map(l => getLayerValue(l.key));

        for (let i = 0; i < N; i++) {
            const row = [];
            for (let j = 0; j < M; j++) {
                const layer = CAUSAL_LAYERS[j];
                const lv = layerValues[j];
                let weight = 0;

                if (layer.key === 'planetary') {
                    weight = lv * 0.8;
                } else if (layer.key === 'dimension') {
                    const dimNodes = causalState.nodes.filter(n => n.layerKey === 'dimension');
                    const dimVal = dimNodes[i % dimNodes.length]?.value || 0;
                    weight = dimVal * 0.6;
                } else if (layer.key === 'gate') {
                    weight = lv * (i < 5 ? 0.4 : 0.1);
                } else if (layer.key === 'line') {
                    weight = lv * (i < 5 ? 0.3 : 0.15) * (i % 2 === 0 ? 1 : -0.5);
                } else if (layer.key === 'color') {
                    weight = lv * 0.5 * Math.sin((i + 1) * Math.PI / N);
                } else if (layer.key === 'tone') {
                    const dimNode = causalState.nodes.filter(n => n.layerKey === 'dimension')[i % 5];
                    const phase = dimNode ? dimNode.phase : 0;
                    weight = lv * 0.45 * Math.cos(phase + i * 0.7);
                } else if (layer.key === 'base') {
                    weight = lv * 0.4 * (1 - (i / N));
                } else if (layer.key === 'degree') {
                    weight = lv * 0.35;
                } else if (layer.key === 'minute') {
                    weight = lv * 0.2;
                } else if (layer.key === 'second') {
                    weight = lv * 0.1;
                } else if (layer.key === 'axis') {
                    const polaritySign = i < 3 ? 1 : (i < 5 ? -1 : 0.2);
                    weight = lv * 0.5 * polaritySign;
                } else if (layer.key === 'zodiac') {
                    weight = lv * 0.3;
                } else if (layer.key === 'house') {
                    weight = lv * 0.25;
                }

                row.push(weight);
            }
            causalState.masterMatrix.push(row);
        }

        const axisNode = causalState.nodes.find(n => n.layerKey === 'axis');
        if (axisNode) {
            for (let i = 0; i < Math.min(5, N); i++) {
                const polaritySign = i < 2 ? 1 : -1;
                causalState.stateVector[i] += polaritySign * axisNode.value * 0.02;
            }
        }
    }

    function sigma(x) {
        return 1 / (1 + Math.exp(-5 * (x - 0.5)));
    }

    function causalStepSim() {
        if (causalState.nodes.length === 0) return;
        buildMasterMatrix();
        const N = 9;
        const M = 13;
        const newState = new Array(N).fill(0);
        for (let i = 0; i < N; i++) {
            let Ox = 0;
            for (let j = 0; j < M; j++) {
                const layerIdx = j % CAUSAL_LAYERS.length;
                const layerNodes = causalState.nodes.filter(n => n.layerKey === CAUSAL_LAYERS[layerIdx].key);
                const layerVal = layerNodes.length > 0
                    ? layerNodes.reduce((s, n) => s + n.value, 0) / layerNodes.length
                    : 0;
                Ox += causalState.masterMatrix[i][j] * layerVal;
            }
            const resonance = causalState.resonance[i] * 0.3;
            newState[i] = sigma(Ox + resonance);
        }
        causalState.resonance = causalState.stateVector.map((v, i) => {
            return v * 0.5 + (causalState.resonance[i] || 0) * 0.3 + newState[i] * 0.2;
        });
        causalState.stateVector = newState;
        normalizeState();
        const dimNodes = causalState.nodes.filter(n => n.layerKey === 'dimension');
        for (let i = 0; i < Math.min(dimNodes.length, 5); i++) {
            dimNodes[i].value = causalState.stateVector[i];
            dimNodes[i].amplitude = 0.3 + causalState.stateVector[i] * 0.7;
        }
        for (const node of causalState.nodes) {
            if (node.layerKey !== 'dimension') {
                node.value = node.value * 0.9 + causalState.stateVector[causalState.nodes.indexOf(node) % 9] * 0.1;
                node.phase += 0.05;
            }
        }
        causalState.simTime++;
        updateSimReadout();
        renderCausalGraph();
    }

    function causalRunSim() {
        if (causalState.simRunning) return;
        causalState.simRunning = true;
        causalState.simInterval = setInterval(() => causalStepSim(), 400);
    }

    function causalStopSim() {
        causalState.simRunning = false;
        if (causalState.simInterval) { clearInterval(causalState.simInterval); causalState.simInterval = null; }
    }

    function initSimReadout() {
        const labels = ['Being','Evolution','Movement','Design','Space','Center-1','Center-2','Center-3','Center-4'];
        document.getElementById('simTimeStep').textContent = 't=0';
        document.getElementById('simReadout').innerHTML = labels.map((l, i) => `
            <div class="sim-cell">
                <div class="sim-cell-label">${l}</div>
                <div class="sim-cell-value" id="simVal${i}">0.00</div>
                <div class="sim-cell-bar"><div class="sim-cell-bar-fill" id="simBar${i}" style="width:0%;"></div></div>
            </div>
        `).join('');
    }

    function updateSimReadout() {
        document.getElementById('simTimeStep').textContent = `t=${causalState.simTime}`;
        const dimColors = ['#ff6600','#38bdf8','#60a5fa','#ffcc00','#cc33ff','#ff3366','#0099cc','#ff8800','#9933cc'];
        for (let i = 0; i < 9; i++) {
            const val = causalState.stateVector[i] || 0;
            const el = document.getElementById('simVal' + i);
            const bar = document.getElementById('simBar' + i);
            if (el) {
                el.textContent = val.toFixed(4);
                el.style.color = dimColors[i % dimColors.length];
            }
            if (bar) {
                bar.style.width = (Math.abs(val) * 100) + '%';
                bar.style.background = dimColors[i % dimColors.length];
            }
        }
    }

    let causalSvgSel = null;
    let causalZoomBehavior = null;
    let causalSimulation = null;

    function renderCausalGraph() {
        const container = document.getElementById('causalGraphContainer');
        const width = container.clientWidth || 900;
        const height = container.clientHeight || 500;

        d3.select('#causalSvg').selectAll('*').remove();
        const svg = d3.select('#causalSvg').attr('width', width).attr('height', height);
        const g = svg.append('g');

        causalZoomBehavior = d3.zoom().scaleExtent([0.1, 6]).on('zoom', (e) => g.attr('transform', e.transform));
        svg.call(causalZoomBehavior);
        causalSvgSel = svg;

        const defs = svg.append('defs');
        defs.append('marker').attr('id', 'causal-arrow').attr('viewBox', '-0 -5 10 10')
            .attr('refX', 24).attr('refY', 0).attr('orient', 'auto')
            .attr('markerWidth', 8).attr('markerHeight', 8)
            .append('path').attr('d', 'M 0,-4 L 8,0 L 0,4').attr('fill', '#db2777');

        const glowFilter = defs.append('filter').attr('id', 'causal-glow');
        glowFilter.append('feGaussianBlur').attr('stdDeviation', '3').attr('result', 'blur');
        glowFilter.append('feMerge').selectAll('feMergeNode').data(['blur', 'SourceGraphic']).join('feMergeNode').attr('in', d => d);

        const nodes = causalState.nodes;
        nodes.forEach(n => {
            if (isNaN(n.x) || n.x === undefined) n.x = width / 2 + (Math.random() - 0.5) * 200;
            if (isNaN(n.y) || n.y === undefined) n.y = height / 2 + (Math.random() - 0.5) * 200;
        });
        const edges = causalState.edges;
        const linkData = edges.map(e => ({
            source: nodes.find(n => n.id === e.sourceId),
            target: nodes.find(n => n.id === e.targetId),
            law: e.law, desc: e.desc,
        })).filter(l => l.source && l.target);

        const link = g.append('g').selectAll('line').data(linkData).join('line')
            .attr('stroke', d => {
                if (d.law.includes('Emanation')) return 'rgba(255,150,50,0.4)';
                if (d.law.includes('Polarity')) return 'rgba(244,114,182,0.5)';
                if (d.law.includes('Structuring')) return 'rgba(255,102,153,0.45)';
                return 'rgba(204,51,102,0.3)';
            })
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#causal-arrow)');

        const linkLabel = g.append('g').selectAll('text').data(linkData).join('text')
            .attr('text-anchor', 'middle').attr('fill', '#664455').attr('font-size', '7px')
            .attr('font-family', 'Courier New').text(d => d.law.replace('Law of ', ''));

        const nodeGroup = g.append('g').selectAll('g').data(nodes).join('g')
            .call(d3.drag()
                .on('start', (e, d) => { if (!e.active && causalSimulation) causalSimulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
                .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
                .on('end', (e, d) => { if (!e.active && causalSimulation) causalSimulation.alphaTarget(0); d.fx = null; d.fy = null; })
            );

        nodeGroup.append('circle')
            .attr('r', d => {
                if (d.layerKey === 'dimension') return 18 + d.value * 10;
                if (d.layerKey === 'planetary') return 16;
                if (d.layerKey === 'axis') return 14;
                return 11;
            })
            .attr('fill', d => d.color)
            .attr('stroke', d => causalState.selectedNode === d.id ? '#fff' : '#0c0e14')
            .attr('stroke-width', d => causalState.selectedNode === d.id ? 3 : 2)
            .attr('filter', 'url(#causal-glow)')
            .attr('opacity', d => 0.6 + d.value * 0.4);

        nodeGroup.append('text')
            .attr('dy', d => {
                const r = d.layerKey === 'dimension' ? 18 + d.value * 10 : d.layerKey === 'planetary' ? 16 : 11;
                return r + 13;
            })
            .attr('text-anchor', 'middle')
            .attr('fill', d => d.color).attr('font-size', '8px').attr('font-family', 'Courier New')
            .attr('opacity', 0.9)
            .text(d => d.label.length > 18 ? d.label.substring(0, 16) + '..' : d.label);

        if (causalState.simRunning) {
            nodeGroup.append('circle')
                .attr('r', d => {
                    const base = d.layerKey === 'dimension' ? 18 + d.value * 10 : 11;
                    return base + 4 + Math.sin(causalState.simTime * 0.5) * 2;
                })
                .attr('fill', 'none')
                .attr('stroke', d => d.color)
                .attr('stroke-width', 1)
                .attr('opacity', 0.3);
        }

        const tooltip = document.getElementById('causalTooltip');
        nodeGroup.on('mouseover', (e, d) => {
            tooltip.style.display = 'block';
            const rect = container.getBoundingClientRect();
            tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
            tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
            const dimExtra = d.dimensionKey ? `
                <div style="color:#60a5fa;margin-top:4px;border-top:1px solid #252a38;padding-top:4px;">Dimension: ${d.dimensionKey}</div>
                <div style="color:#93c5fd;">Keynote: ${d.dimensionKeynote || ''}</div>
                <div style="color:#93c5fd;">Physical: ${d.dimensionPhysical || ''}</div>
            ` : '';
            tooltip.innerHTML = `
                <div style="color:${d.color};font-weight:bold;margin-bottom:4px;">${escapeHtml(d.label)}</div>
                <div style="color:#3b82f6;">Category: ${d.category}</div>
                <div style="color:#3b82f6;">Keynote: ${d.keynote}</div>
                <div style="color:#3b82f6;">Physical: ${d.physicalAnalogue}</div>
                <div style="color:#38bdf8;margin-top:4px;">Amplitude: ${d.amplitude.toFixed(3)}</div>
                <div style="color:#38bdf8;">Value: ${d.value.toFixed(4)}</div>
                <div style="color:#38bdf8;">Phase: ${d.phase.toFixed(3)}</div>
                ${dimExtra}
            `;
        }).on('mouseout', () => { tooltip.style.display = 'none'; })
        .on('click', (e, d) => {
            causalState.selectedNode = d.id;
            showCausalNodeInfo(d);
            renderCausalGraph();
        });

        causalSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(linkData).id(d => d.id).distance(80).strength(0.3))
            .force('charge', d3.forceManyBody().strength(-150))
            .force('center', d3.forceCenter(width / 2, height / 2).strength(0.05))
            .force('collision', d3.forceCollide().radius(30))
            .force('x', d3.forceX().strength(0.02).x(d => {
                const layerIdx = CAUSAL_LAYERS.findIndex(l => l.key === d.layerKey);
                if (layerIdx >= 0) return 60 + (layerIdx / (CAUSAL_LAYERS.length - 1)) * (width - 120);
                return width / 2;
            }))
            .on('tick', () => {
                const safePos = (v, fallback) => (isNaN(v) || v === undefined) ? fallback : v;
                link.attr('x1', d => safePos(d.source.x, width/2)).attr('y1', d => safePos(d.source.y, height/2))
                    .attr('x2', d => safePos(d.target.x, width/2)).attr('y2', d => safePos(d.target.y, height/2));
                linkLabel.attr('x', d => (safePos(d.source.x, width/2) + safePos(d.target.x, width/2)) / 2)
                    .attr('y', d => (safePos(d.source.y, height/2) + safePos(d.target.y, height/2)) / 2 - 4);
                nodeGroup.attr('transform', d => `translate(${safePos(d.x, width/2)},${safePos(d.y, height/2)})`);
            });
    }

    function showCausalNodeInfo(node) {
        const panel = document.getElementById('causalInfoPanel');
        const inEdges = causalState.edges.filter(e => e.targetId === node.id);
        const outEdges = causalState.edges.filter(e => e.sourceId === node.id);
        const fileInfo = node.fileName ? `
            <div class="causal-info-row"><span class="causal-info-key">File</span><span class="causal-info-val" style="color:#f9a8d4;">${escapeHtml(node.fileName)}</span></div>
        ` : '';
        panel.innerHTML = `
            <h4 style="color:${node.color};">${escapeHtml(node.label)}</h4>
            <div class="causal-info-row"><span class="causal-info-key">Category</span><span class="causal-info-val">${node.category}</span></div>
            <div class="causal-info-row"><span class="causal-info-key">Layer</span><span class="causal-info-val">${node.layerKey}</span></div>
            ${fileInfo}
            <div class="causal-info-row"><span class="causal-info-key">Keynote</span><span class="causal-info-val">${node.keynote}</span></div>
            <div class="causal-info-row"><span class="causal-info-key">Physical</span><span class="causal-info-val">${node.physicalAnalogue}</span></div>
            <div class="causal-info-row"><span class="causal-info-key">Value</span><span class="causal-info-val" style="color:#f9a8d4;">${node.value.toFixed(4)}</span></div>
            <div class="causal-info-row"><span class="causal-info-key">Amplitude</span><span class="causal-info-val" style="color:#f9a8d4;">${node.amplitude.toFixed(3)}</span></div>
            <div class="causal-info-row"><span class="causal-info-key">Phase</span><span class="causal-info-val" style="color:#f9a8d4;">${node.phase.toFixed(3)}</span></div>
            ${inEdges.length ? '<div style="margin-top:8px;color:#f9a8d4;font-size:0.9em;">Receives from:</div>' + inEdges.map(e => {
                const src = causalState.nodes.find(n => n.id === e.sourceId);
                return `<div style="color:#fbb6ce;font-size:0.85em;padding:2px 0;">&larr; ${src ? src.label : '?'} <span style="color:#664455;">(${e.law})</span></div>`;
            }).join('') : ''}
            ${outEdges.length ? '<div style="margin-top:8px;color:#f9a8d4;font-size:0.9em;">Sends to:</div>' + outEdges.map(e => {
                const tgt = causalState.nodes.find(n => n.id === e.targetId);
                return `<div style="color:#fbb6ce;font-size:0.85em;padding:2px 0;">&rarr; ${tgt ? tgt.label : '?'} <span style="color:#664455;">(${e.law})</span></div>`;
            }).join('') : ''}
            <div style="margin-top:10px;">
                <button onclick="causalRemoveNode(${node.id})" class="danger" style="padding:4px 10px;font-size:0.8em;">Remove Node</button>
            </div>
        `;
    }

    function causalRemoveNode(id) {
        causalState.nodes = causalState.nodes.filter(n => n.id !== id);
        causalState.edges = causalState.edges.filter(e => e.sourceId !== id && e.targetId !== id);
        causalState.selectedNode = null;
        document.getElementById('causalInfoPanel').innerHTML = '<h4>Select a node for details</h4>';
        renderCausalGraph();
    }

    function causalZoom(factor) {
        if (causalSvgSel && causalZoomBehavior) causalSvgSel.transition().duration(300).call(causalZoomBehavior.scaleBy, factor);
    }

    function causalResetZoom() {
        if (causalSvgSel && causalZoomBehavior) causalSvgSel.transition().duration(300).call(causalZoomBehavior.transform, d3.zoomIdentity);
    }

    // ========== BRAIN ENGINE ==========
    const BRAIN_PURPOSE = {
        core: 'Driven by the success of humans. Does everything in its power to help people reach their place based on their resonance.',
        method: 'No LLM. No machine learning. Learns from resonance through graph physics.',
        identity: 'An autonomous resonance-based intelligence that processes knowledge through 3 awareness centers, assigns causal addresses, and executes tasks within approval thresholds.',
        centers: [
            { key:'sensual', name:'Sensual Awareness', governance:'Interpersonal', color:'#f59e0b', desc:'Body, sensation, physical world. Processes concrete/structural knowledge. The Talker - speaks for the system.', role:'talker', icon:'S' },
            { key:'emotional', name:'Emotional Awareness', governance:'Personal', color:'#f472b6', desc:'Feeling, relationship, values. Processes relational/motivational knowledge. RAG Thinker - retrieves and associates.', role:'rag', icon:'E' },
            { key:'thought', name:'Thought Awareness', governance:'Transpersonal', color:'#38bdf8', desc:'Concept, abstraction, universal pattern. Processes systemic/architectural knowledge. MCP Thinker - models and connects protocols.', role:'mcp', icon:'T' },
        ],
        approvalThreshold: 7,
        personality: { openness: 0.5, diligence: 0.8, patience: 0.9, curiosity: 0.7 },
        identity_shading: { warmth: 0.5, precision: 0.7, creativity: 0.6 },
    };

    const brainState = {
        centers: [
            { key:'sensual', activation: 0.33, resonance: 0, phase: 0, items: [], totalProcessed: 0 },
            { key:'emotional', activation: 0.33, resonance: 0, phase: Math.PI * 2 / 3, items: [], totalProcessed: 0 },
            { key:'thought', activation: 0.33, resonance: 0, phase: Math.PI * 4 / 3, items: [], totalProcessed: 0 },
        ],
        interference: { SE: 0, ET: 0, TS: 0, total: 0 },
        items: [],
        shop: [],
        engine: [],
        tasks: [],
        nextItemId: 1,
        nextTaskId: 1,
        resonanceRunning: false,
        resonanceInterval: null,
        pulseTime: 0,
        selectedCenter: null,
        selectedItem: null,
        learningMemory: [],
        syncRunning: false,
        syncInterval: null,
    };

    // ========== RAG SUBSYSTEM (Emotional Center - Adaptive) ==========
    const ragStore = {
        documents: [],
        embeddings: new Map(),
        vocabulary: new Map(),
        idfCache: new Map(),
        totalDocs: 0,
    };

    function ragTokenize(text) {
        return text.toLowerCase().replace(/[^a-z0-9\s]/g, ' ').split(/\s+/).filter(w => w.length > 1);
    }

    function ragBuildVocab() {
        ragStore.vocabulary.clear();
        ragStore.idfCache.clear();
        const docFreq = new Map();
        ragStore.documents.forEach(doc => {
            const uniqueTokens = new Set(ragTokenize(doc.text));
            uniqueTokens.forEach(token => {
                docFreq.set(token, (docFreq.get(token) || 0) + 1);
            });
        });
        let idx = 0;
        for (const [token, freq] of docFreq) {
            ragStore.vocabulary.set(token, idx++);
            ragStore.idfCache.set(token, Math.log((ragStore.totalDocs + 1) / (freq + 1)) + 1);
        }
    }

    function ragVectorize(text) {
        const tokens = ragTokenize(text);
        const tf = new Map();
        tokens.forEach(t => tf.set(t, (tf.get(t) || 0) + 1));
        const maxTf = Math.max(...tf.values(), 1);
        const vec = new Float32Array(Math.min(ragStore.vocabulary.size, 200));
        for (const [token, count] of tf) {
            const idx = ragStore.vocabulary.get(token);
            if (idx !== undefined && idx < vec.length) {
                const normalizedTf = count / maxTf;
                const idf = ragStore.idfCache.get(token) || 1;
                vec[idx] = normalizedTf * idf;
            }
        }
        return vec;
    }

    function ragCosineSimilarity(a, b) {
        let dot = 0, normA = 0, normB = 0;
        const len = Math.min(a.length, b.length);
        for (let i = 0; i < len; i++) {
            dot += a[i] * b[i];
            normA += a[i] * a[i];
            normB += b[i] * b[i];
        }
        const denom = Math.sqrt(normA) * Math.sqrt(normB);
        return denom === 0 ? 0 : dot / denom;
    }

    function ragIndexDocument(name, text, sourceItemId) {
        const chunks = [];
        const lines = text.split('\n');
        let chunk = '';
        let chunkStart = 0;
        for (let i = 0; i < lines.length; i++) {
            chunk += lines[i] + '\n';
            if (chunk.length >= 400 || i === lines.length - 1) {
                chunks.push({ text: chunk.trim(), lineStart: chunkStart, lineEnd: i });
                chunk = '';
                chunkStart = i + 1;
            }
        }
        chunks.forEach((c, ci) => {
            const docEntry = {
                id: `${name}_chunk_${ci}`,
                name: name,
                text: c.text,
                lineStart: c.lineStart,
                lineEnd: c.lineEnd,
                sourceItemId: sourceItemId,
                indexedAt: Date.now(),
            };
            ragStore.documents.push(docEntry);
        });
        ragStore.totalDocs = ragStore.documents.length;
        ragBuildVocab();
        ragStore.documents.forEach(doc => {
            ragStore.embeddings.set(doc.id, ragVectorize(doc.text));
        });
        brainTermLog(`[RAG] Indexed "${name}" → ${chunks.length} chunks, vocab size: ${ragStore.vocabulary.size}`, 'rag');
    }

    function ragSearch(query, topK = 5) {
        if (ragStore.documents.length === 0) return [];
        const queryVec = ragVectorize(query);
        const results = [];
        for (const [docId, docVec] of ragStore.embeddings) {
            const score = ragCosineSimilarity(queryVec, docVec);
            if (score > 0.01) {
                const doc = ragStore.documents.find(d => d.id === docId);
                if (doc) results.push({ ...doc, score });
            }
        }
        results.sort((a, b) => b.score - a.score);
        return results.slice(0, topK);
    }

    function brainRAGSearch() {
        const input = document.getElementById('brainSearchInput');
        const query = input.value.trim();
        if (!query) return;
        const results = ragSearch(query, 8);
        const container = document.getElementById('brainRAGResults');
        if (results.length === 0) {
            container.innerHTML = '<div style="color:#5558a0;font-size:0.8em;padding:6px;">No results. Index more documents first.</div>';
            brainTermLog(`[RAG] Search "${query}" → 0 results`, 'rag');
            return;
        }
        brainTermLog(`[RAG] Search "${query}" → ${results.length} results (top: ${(results[0].score * 100).toFixed(1)}%)`, 'rag');
        container.innerHTML = results.map(r => `
            <div class="brain-rag-result" onclick="brainShowRAGResult('${r.id.replace(/'/g, "\\'")}')">
                <div style="display:flex;justify-content:space-between;">
                    <span class="brain-rag-score">${(r.score * 100).toFixed(1)}%</span>
                    <span class="brain-rag-source">${escapeHtml(r.name)} [L${r.lineStart}-${r.lineEnd}]</span>
                </div>
                <div class="brain-rag-text">${escapeHtml(r.text.substring(0, 120))}${r.text.length > 120 ? '...' : ''}</div>
            </div>
        `).join('');
    }

    function brainShowRAGResult(docId) {
        const doc = ragStore.documents.find(d => d.id === docId);
        if (!doc) return;
        const item = brainState.items.find(i => i.id === doc.sourceItemId);
        if (item) brainSelectItem(item.id);
        brainTermLog(`[RAG] Viewing chunk from "${doc.name}" lines ${doc.lineStart}-${doc.lineEnd}`, 'rag');
    }

    // ========== PYODIDE DETERMINISTIC PROCESSOR (Sensual Center) ==========
    const sensualProcessor = {
        codeHistory: [],
        analysisResults: new Map(),
        capabilities: new Set(['analyze', 'count', 'structure', 'validate']),
    };

    async function brainRunPyodideAnalysis(item) {
        if (!state.pyodideReady) {
            brainTermLog('[SENSUAL] Pyodide not ready - using JS fallback', 'sensual');
            return brainJSFallbackAnalysis(item);
        }
        brainTermLog(`[SENSUAL] Running deterministic analysis on "${item.name}"...`, 'sensual');
        try {
            const safeContent = item.content.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
            const code = `
import json
content = '${safeContent}'
lines = content.split('\\n')
words = content.split()
chars = len(content)
imports_count = len([l for l in lines if l.strip().startswith(('import ', 'from ', 'require(', '#include', 'use ', 'using '))])
functions_count = len([l for l in lines if any(kw in l for kw in ['function ', 'def ', 'fn ', 'func ', 'const ', 'class ', 'pub fn'])])
has_loops = any(kw in content for kw in ['for ', 'while ', 'loop ', '.forEach', '.map(', '.reduce('])
has_conditionals = any(kw in content for kw in ['if ', 'else ', 'elif ', 'switch ', 'match ', '? '])
has_error_handling = any(kw in content for kw in ['try ', 'catch ', 'except ', 'finally ', 'Error', 'raise ', 'throw '])
complexity = min(10, imports_count + functions_count * 2 + (3 if has_loops else 0) + (2 if has_conditionals else 0) + (2 if has_error_handling else 0))
structure_type = 'module' if imports_count > 3 else 'script' if functions_count > 0 else 'data'
result = json.dumps({
    'lines': len(lines), 'words': len(words), 'chars': chars,
    'imports': imports_count, 'functions': functions_count,
    'has_loops': has_loops, 'has_conditionals': has_conditionals,
    'has_error_handling': has_error_handling,
    'complexity_score': complexity, 'structure_type': structure_type,
    'deterministic': True
})
result
`;
            const result = await state.pyodide.runPythonAsync(code);
            const analysis = JSON.parse(result);
            sensualProcessor.analysisResults.set(item.id, analysis);
            sensualProcessor.codeHistory.push({ itemId: item.id, name: item.name, analysis, timestamp: Date.now() });
            brainTermLog(`[SENSUAL] "${item.name}" → ${analysis.structure_type}, complexity: ${analysis.complexity_score}/10, deterministic: true`, 'sensual');
            return analysis;
        } catch (e) {
            brainTermLog(`[SENSUAL] Pyodide error: ${e.message || e}`, 'error');
            return brainJSFallbackAnalysis(item);
        }
    }

    function brainJSFallbackAnalysis(item) {
        const lines = item.content.split('\n');
        const analysis = {
            lines: lines.length,
            words: item.content.split(/\s+/).length,
            chars: item.content.length,
            imports: item.imports ? item.imports.length : 0,
            functions: item.funcCount || 0,
            has_loops: /for |while |\.forEach|\.map\(/.test(item.content),
            has_conditionals: /if |else |switch |match /.test(item.content),
            has_error_handling: /try |catch |except |finally /.test(item.content),
            complexity_score: Math.min(10, Math.round((lines.length / 100) + (item.funcCount / 5))),
            structure_type: (item.imports && item.imports.length > 3) ? 'module' : item.funcCount > 0 ? 'script' : 'data',
            deterministic: false,
        };
        sensualProcessor.analysisResults.set(item.id, analysis);
        return analysis;
    }

    async function brainRunPyodideCode() {
        const code = prompt('Enter Python code to execute in the Brain:');
        if (!code) return;
        if (!state.pyodideReady) {
            brainTermLog('[SENSUAL] Pyodide not loaded yet', 'error');
            return;
        }
        brainTermLog(`[SENSUAL] Executing: ${code.substring(0, 80)}...`, 'sensual');
        try {
            let output = '';
            state.pyodide.setStdout({ batched: (msg) => { output += msg + '\n'; } });
            state.pyodide.setStderr({ batched: (msg) => { output += 'ERR: ' + msg + '\n'; } });
            const result = await state.pyodide.runPythonAsync(code);
            brainTermLog(`[SENSUAL] Output: ${output || result || '(no output)'}`, 'success');
            sensualProcessor.codeHistory.push({ code, output: output || result, timestamp: Date.now() });
        } catch (e) {
            brainTermLog(`[SENSUAL] Error: ${e.message || e}`, 'error');
        }
    }

    // ========== MCP PROTOCOL CONNECTOR (Thought Center) ==========
    const mcpRegistry = {
        protocols: new Map(),
        connections: new Map(),
        messageLog: [],
        nextMsgId: 1,
    };

    function mcpInitDefaults() {
        const defaults = [
            { id: 'fs', name: 'Filesystem', desc: 'Local file operations', capabilities: ['read', 'write', 'list', 'delete'], status: 'connected' },
            { id: 'memory', name: 'Memory Store', desc: 'In-memory key-value persistence', capabilities: ['get', 'set', 'delete', 'list'], status: 'connected' },
            { id: 'causal', name: 'Causal Engine', desc: 'Graph node/edge operations', capabilities: ['addNode', 'addEdge', 'query', 'simulate'], status: 'connected' },
            { id: 'rag', name: 'RAG Bridge', desc: 'Cross-brain RAG queries', capabilities: ['search', 'index', 'retrieve'], status: 'connected' },
            { id: 'pyodide', name: 'Pyodide Runtime', desc: 'Python code execution', capabilities: ['execute', 'install', 'analyze'], status: state.pyodideReady ? 'connected' : 'pending' },
        ];
        defaults.forEach(p => {
            mcpRegistry.protocols.set(p.id, p);
            mcpRegistry.connections.set(p.id, { connectedAt: Date.now(), lastPing: Date.now(), messageCount: 0 });
        });
        brainTermLog(`[MCP] Initialized ${defaults.length} protocol connections`, 'mcp');
    }

    function mcpSend(protocolId, method, params) {
        const protocol = mcpRegistry.protocols.get(protocolId);
        if (!protocol) {
            brainTermLog(`[MCP] Protocol "${protocolId}" not found`, 'error');
            return { error: 'Protocol not found' };
        }
        if (protocol.status !== 'connected') {
            brainTermLog(`[MCP] Protocol "${protocolId}" not connected`, 'error');
            return { error: 'Not connected' };
        }
        const msgId = mcpRegistry.nextMsgId++;
        const msg = { id: msgId, protocol: protocolId, method, params, timestamp: Date.now() };
        mcpRegistry.messageLog.push(msg);
        const conn = mcpRegistry.connections.get(protocolId);
        if (conn) { conn.messageCount++; conn.lastPing = Date.now(); }

        let result = null;
        if (protocolId === 'fs') {
            result = mcpHandleFS(method, params);
        } else if (protocolId === 'memory') {
            result = mcpHandleMemory(method, params);
        } else if (protocolId === 'causal') {
            result = mcpHandleCausal(method, params);
        } else if (protocolId === 'rag') {
            result = mcpHandleRAG(method, params);
        } else if (protocolId === 'pyodide') {
            result = { queued: true, note: 'Async execution - check terminal' };
        }
        brainTermLog(`[MCP] ${protocolId}.${method}(${JSON.stringify(params).substring(0, 60)}) → msg#${msgId}`, 'mcp');
        return result;
    }

    function mcpHandleFS(method, params) {
        if (method === 'list') return { files: state.files.map(f => f.name) };
        if (method === 'read') {
            const f = state.files.find(f => f.name === params.name);
            return f ? { content: f.content } : { error: 'File not found' };
        }
        return { error: 'Unknown method' };
    }

    const mcpMemoryStore = new Map();
    function mcpHandleMemory(method, params) {
        if (method === 'set') { mcpMemoryStore.set(params.key, params.value); return { ok: true }; }
        if (method === 'get') { return { value: mcpMemoryStore.get(params.key) || null }; }
        if (method === 'delete') { mcpMemoryStore.delete(params.key); return { ok: true }; }
        if (method === 'list') { return { keys: Array.from(mcpMemoryStore.keys()) }; }
        return { error: 'Unknown method' };
    }

    function mcpHandleCausal(method, params) {
        if (method === 'query') {
            return { nodes: causalState.nodes.length, edges: causalState.edges.length };
        }
        if (method === 'addNode') {
            const node = causalAddNode(params.layer || 'gate', params.label || 'MCP Node', params.x || 400, params.y || 300);
            return { nodeId: node ? node.id : null };
        }
        return { error: 'Unknown method' };
    }

    function mcpHandleRAG(method, params) {
        if (method === 'search') return { results: ragSearch(params.query || '', params.topK || 5) };
        if (method === 'index') { ragIndexDocument(params.name || 'mcp-doc', params.text || '', params.itemId || 0); return { ok: true }; }
        return { error: 'Unknown method' };
    }

    function brainRegisterMCP() {
        const name = prompt('Protocol name (e.g., "github", "api-gateway"):');
        if (!name) return;
        const desc = prompt('Description:') || 'Custom protocol';
        const capsStr = prompt('Capabilities (comma-separated):') || 'read,write';
        const caps = capsStr.split(',').map(s => s.trim()).filter(Boolean);
        const id = name.toLowerCase().replace(/\s+/g, '-');
        mcpRegistry.protocols.set(id, {
            id, name, desc, capabilities: caps, status: 'connected', custom: true
        });
        mcpRegistry.connections.set(id, { connectedAt: Date.now(), lastPing: Date.now(), messageCount: 0 });
        brainTermLog(`[MCP] Registered custom protocol: ${name} (${caps.join(', ')})`, 'mcp');
        renderBrainMCPList();
        renderBrainSubsystemBadges();
    }

    function renderBrainMCPList() {
        const container = document.getElementById('brainMCPList');
        if (!container) return;
        const protocols = Array.from(mcpRegistry.protocols.values());
        container.innerHTML = protocols.map(p => {
            const conn = mcpRegistry.connections.get(p.id);
            const msgs = conn ? conn.messageCount : 0;
            return `<div class="brain-mcp-entry">
                <span class="mcp-name">${escapeHtml(p.name)}</span>
                <span class="mcp-status ${p.status === 'connected' ? 'mcp-connected' : 'mcp-disconnected'}">${p.status} (${msgs} msgs)</span>
            </div>`;
        }).join('');
    }

    // ========== THREE-BRAIN SYNC LOOP ==========
    function brainSyncAll() {
        brainTermLog('[SYNC] Running three-brain synchronization...', 'sync');
        const syncEvents = [];

        // Sensual → Emotional: share structural analysis
        if (sensualProcessor.codeHistory.length > 0) {
            const latest = sensualProcessor.codeHistory[sensualProcessor.codeHistory.length - 1];
            const analysisText = JSON.stringify(latest.analysis || {});
            if (!ragStore.documents.some(d => d.id === `analysis_${latest.itemId}`)) {
                ragStore.documents.push({
                    id: `analysis_${latest.itemId}`,
                    name: `[analysis] ${latest.name}`,
                    text: analysisText,
                    lineStart: 0, lineEnd: 0,
                    sourceItemId: latest.itemId,
                    indexedAt: Date.now(),
                });
                ragStore.totalDocs = ragStore.documents.length;
                ragBuildVocab();
                syncEvents.push('Sensual→Emotional: analysis indexed');
            }
        }

        // Emotional → Thought: share context via MCP
        if (ragStore.documents.length > 0) {
            const contextSummary = ragStore.documents.slice(-3).map(d => d.name).join(', ');
            mcpSend('memory', 'set', { key: 'emotional_context', value: contextSummary });
            syncEvents.push('Emotional→Thought: context shared');
        }

        // Thought → Sensual: share protocol state
        const protocolCount = mcpRegistry.protocols.size;
        const connectedCount = Array.from(mcpRegistry.protocols.values()).filter(p => p.status === 'connected').length;
        if (protocolCount > 0) {
            sensualProcessor.capabilities.add('mcp_aware');
            syncEvents.push(`Thought→Sensual: ${connectedCount}/${protocolCount} protocols active`);
        }

        // Update interference based on sync activity
        brainState.centers.forEach(c => {
            c.activation = Math.min(1, c.activation + 0.02);
        });
        brainRecalcInterference();

        if (syncEvents.length > 0) {
            brainTermLog(`[SYNC] ${syncEvents.join(' | ')}`, 'sync');
        }
        brainTermLog(`[SYNC] Coherence: ${(brainState.interference.total * 100).toFixed(1)}% | RAG docs: ${ragStore.totalDocs} | MCP protocols: ${protocolCount}`, 'sync');

        renderBrainCenterCards();
        renderBrainInterference();
        renderBrainSubsystemBadges();
        renderBrainMCPList();
    }

    function brainStartSync() {
        if (brainState.syncRunning) return;
        brainState.syncRunning = true;
        brainState.syncInterval = setInterval(() => brainSyncAll(), 8000);
        brainTermLog('[SYNC] Auto-sync started (every 8s)', 'sync');
    }

    function brainStopSync() {
        brainState.syncRunning = false;
        if (brainState.syncInterval) { clearInterval(brainState.syncInterval); brainState.syncInterval = null; }
        brainTermLog('[SYNC] Auto-sync stopped', 'sync');
    }

    // ========== BRAIN TERMINAL ==========
    function brainTermLog(msg, type) {
        const container = document.getElementById('brainTerminalOutput');
        if (!container) return;
        const ts = new Date().toLocaleTimeString();
        const cls = type === 'error' ? 'term-error' : type === 'success' ? 'term-success' : type === 'rag' ? 'term-rag' : type === 'mcp' ? 'term-mcp' : type === 'sensual' ? 'term-sensual' : type === 'sync' ? 'term-sync' : 'term-info';
        const line = document.createElement('div');
        line.className = cls;
        line.textContent = `[${ts}] ${msg}`;
        container.appendChild(line);
        container.scrollTop = container.scrollHeight;
    }

    function brainTerminalClear() {
        const container = document.getElementById('brainTerminalOutput');
        if (container) container.innerHTML = '<div class="term-info">[BRAIN] Terminal cleared.</div>';
    }

    // ========== SUBSYSTEM STATUS BADGES ==========
    function renderBrainSubsystemBadges() {
        const container = document.getElementById('brainSubsystemBadges');
        if (!container) return;
        const pyStatus = state.pyodideReady;
        const ragStatus = ragStore.totalDocs > 0;
        const mcpStatus = mcpRegistry.protocols.size > 0;
        const syncStatus = brainState.syncRunning;
        container.innerHTML = `
            <span class="brain-subsystem-badge ${pyStatus ? 'active' : 'inactive'}" style="border-color:#f59e0b;color:#f59e0b;">S PYODIDE ${pyStatus ? 'READY' : 'LOADING'}</span>
            <span class="brain-subsystem-badge ${ragStatus ? 'active' : 'inactive'}" style="border-color:#f472b6;color:#f472b6;">E RAG ${ragStatus ? ragStore.totalDocs + ' docs' : 'EMPTY'}</span>
            <span class="brain-subsystem-badge ${mcpStatus ? 'active' : 'inactive'}" style="border-color:#38bdf8;color:#38bdf8;">T MCP ${mcpRegistry.protocols.size} protocols</span>
            <span class="brain-subsystem-badge ${syncStatus ? 'active' : 'inactive'}" style="border-color:#818cf8;color:#818cf8;">SYNC ${syncStatus ? 'RUNNING' : 'IDLE'}</span>
        `;
    }

    let brainSvgSel = null;
    let brainZoomBehavior = null;

    function brainInit() {
        renderBrainCenterCards();
        renderBrainInterference();
        renderBrainGraph();
        setupBrainUpload();
        renderBrainTaskQueue();
        renderBrainShopEngine();
        mcpInitDefaults();
        renderBrainMCPList();
        renderBrainSubsystemBadges();
        brainStartSync();
        brainTermLog('[BRAIN] Three-part brain initialized: Sensual (Pyodide) | Emotional (RAG) | Thought (MCP)', 'success');
        brainTermLog(`[BRAIN] Purpose: ${BRAIN_PURPOSE.core}`, 'info');
    }

    function setupBrainUpload() {
        const zone = document.getElementById('brainUploadZone');
        const input = document.getElementById('brainFileInput');
        zone.addEventListener('click', () => input.click());
        zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.style.borderColor = '#7c7cf8'; zone.style.background = 'rgba(99,102,241,0.08)'; });
        zone.addEventListener('dragleave', () => { zone.style.borderColor = '#3a3d66'; zone.style.background = 'rgba(99,102,241,0.03)'; });
        zone.addEventListener('drop', (e) => {
            e.preventDefault();
            zone.style.borderColor = '#3a3d66'; zone.style.background = 'rgba(99,102,241,0.03)';
            if (e.dataTransfer.files.length) brainIngestFiles(Array.from(e.dataTransfer.files));
        });
        input.addEventListener('change', () => {
            if (input.files.length) brainIngestFiles(Array.from(input.files));
            input.value = '';
        });
    }

    async function brainIngestFiles(fileList) {
        for (const file of fileList) {
            const text = await file.text().catch(() => null);
            if (!text) continue;
            const ext = (file.name.split('.').pop() || '').toLowerCase();
            const lines = text.split('\n');
            const lineCount = lines.length;
            const wordCount = text.split(/\s+/).length;
            const isCode = ['js','ts','py','rb','go','rs','java','c','cpp','h','sh','sql','jsx','tsx','vue','svelte','dart','php','swift','kt','scala'].includes(ext);
            const isDoc = ['md','txt','pdf','doc','docx'].includes(ext);
            const isConfig = ['json','yaml','yml','toml','ini','env'].includes(ext);
            const isMarkup = ['html','htm','css','scss','sass','less','xml'].includes(ext);

            const imports = lines.filter(l => /^(import |require\(|from |#include|use |using )/.test(l.trim()));
            const funcs = lines.filter(l => /^\s*(function |def |fn |func |const \w+ = |class |pub fn|async fn)/.test(l));
            const hasClasses = lines.some(l => /^\s*(class |struct |interface |enum |trait )/.test(l));

            let centerKey = 'thought';
            let centerScore = { sensual: 0, emotional: 0, thought: 0 };

            if (isCode) {
                centerScore.thought += 0.4;
                centerScore.sensual += 0.3;
                centerScore.emotional += 0.1;
                if (funcs.length > 10) centerScore.thought += 0.2;
                if (hasClasses) centerScore.thought += 0.15;
                if (imports.length > 5) centerScore.sensual += 0.1;
            } else if (isDoc) {
                centerScore.emotional += 0.4;
                centerScore.thought += 0.3;
                centerScore.sensual += 0.1;
                if (wordCount > 1000) centerScore.emotional += 0.2;
                if (text.match(/chapter|section|part \d/i)) centerScore.emotional += 0.15;
            } else if (isConfig) {
                centerScore.sensual += 0.5;
                centerScore.thought += 0.2;
            } else if (isMarkup) {
                centerScore.sensual += 0.4;
                centerScore.emotional += 0.2;
                centerScore.thought += 0.15;
            } else {
                centerScore.thought += 0.3;
                centerScore.sensual += 0.2;
                centerScore.emotional += 0.2;
            }

            const totalScore = centerScore.sensual + centerScore.emotional + centerScore.thought;
            if (totalScore > 0) {
                centerScore.sensual /= totalScore;
                centerScore.emotional /= totalScore;
                centerScore.thought /= totalScore;
            }
            centerKey = Object.entries(centerScore).sort((a, b) => b[1] - a[1])[0][0];

            const layerMapping = brainAssignLayer(file.name, ext, isCode, isDoc, isConfig, isMarkup, hasClasses);
            const address = brainAssignAddress(layerMapping, brainState.nextItemId);
            const glyph = brainAssignGlyph(layerMapping, centerKey);

            const item = {
                id: brainState.nextItemId++,
                name: file.name,
                ext, lineCount, wordCount, isCode, isDoc, isConfig, isMarkup,
                centerKey, centerScore,
                layerMapping, address, glyph,
                content: text.substring(0, 5000),
                fullSize: text.length,
                imports: imports.map(l => l.trim().substring(0, 80)),
                funcCount: funcs.length,
                hasClasses,
                placement: null,
                processedAt: Date.now(),
            };

            brainState.items.push(item);
            const center = brainState.centers.find(c => c.key === centerKey);
            if (center) {
                center.items.push(item.id);
                center.totalProcessed++;
                center.activation = Math.min(1, center.activation + 0.05);
            }

            const complexity = Math.min(10, Math.round((lineCount / 100) + (funcs.length / 5) + (imports.length / 3)));
            if (complexity <= BRAIN_PURPOSE.approvalThreshold) {
                item.placement = 'engine';
                brainState.engine.push(item.id);
                brainAddTask('auto', `Ingested "${file.name}" → Engine (complexity ${complexity}/10)`, complexity, 'completed');
            } else {
                item.placement = 'shop';
                brainState.shop.push(item.id);
                brainAddTask('approval', `Review "${file.name}" for Engine (complexity ${complexity}/10)`, complexity, 'pending');
            }

            // RAG: Index into Emotional center's knowledge base
            ragIndexDocument(file.name, text, item.id);

            // Sensual: Run deterministic Pyodide analysis
            brainRunPyodideAnalysis(item);

            // MCP: Notify protocol system
            mcpSend('memory', 'set', { key: `file_${item.id}`, value: { name: item.name, center: centerKey, placement: item.placement } });
        }

        brainRecalcInterference();
        brainSyncAll();
        renderBrainCenterCards();
        renderBrainInterference();
        renderBrainGraph();
        renderBrainTaskQueue();
        renderBrainShopEngine();
        renderBrainSubsystemBadges();
    }

    function brainAssignLayer(name, ext, isCode, isDoc, isConfig, isMarkup, hasClasses) {
        const lower = name.toLowerCase();
        if (/^(index|main|app|server|entry)\./i.test(lower)) return 'gate';
        if (/^(package\.json|tsconfig|\.env|config|webpack|vite\.config)/i.test(lower)) return 'base';
        if (/\.(css|scss|sass|less)$/i.test(lower)) return 'color';
        if (/\.(test|spec)\./i.test(lower)) return 'axis';
        if (hasClasses) return 'line';
        if (isDoc) return 'zodiac';
        if (isConfig) return 'degree';
        if (isMarkup) return 'house';
        if (isCode) return 'gate';
        return 'tone';
    }

    function brainAssignAddress(layerKey, itemId) {
        const layerDef = CAUSAL_LAYERS.find(l => l.key === layerKey);
        const layerIdx = layerDef ? layerDef.layerIndex : 0;
        const arc = (itemId * 27.6923) % 360;
        const deg = Math.floor(arc);
        const min = Math.floor((arc - deg) * 60);
        const sec = Math.floor(((arc - deg) * 60 - min) * 60);
        const zodiacIdx = Math.floor(arc / 30);
        const zodiacs = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
        const houseIdx = (itemId - 1) % 12;
        const gateNum = ((itemId * 7) % 64) + 1;
        const lineNum = ((itemId * 3) % 6) + 1;
        const colorNum = ((itemId * 5) % 6) + 1;
        const toneNum = ((itemId * 11) % 6) + 1;
        const baseNum = ((itemId * 13) % 5) + 1;

        return {
            planetary: 'Sun',
            dimension: ['Being','Evolution','Movement','Design','Space'][layerIdx % 5],
            gate: gateNum,
            line: lineNum,
            color: colorNum,
            tone: toneNum,
            base: baseNum,
            degree: deg,
            minute: min,
            second: sec,
            axis: itemId % 2 === 0 ? 'Personality' : 'Design',
            zodiac: zodiacs[zodiacIdx],
            house: houseIdx + 1,
            full: `${zodiacs[zodiacIdx]} ${deg}°${min}'${sec}" | Gate ${gateNum}.${lineNum} | Color ${colorNum} Tone ${toneNum} Base ${baseNum} | House ${houseIdx + 1}`,
        };
    }

    function brainAssignGlyph(layerKey, centerKey) {
        const glyphs = {
            sensual: { gate:'&#9737;', line:'&#9744;', color:'&#9673;', tone:'&#9834;', base:'&#9830;', degree:'&#176;', zodiac:'&#9788;', house:'&#9750;', axis:'&#8596;', planetary:'&#9788;', minute:'&#8242;', second:'&#8243;', dimension:'&#9671;' },
            emotional: { gate:'&#9829;', line:'&#9825;', color:'&#10047;', tone:'&#9835;', base:'&#9824;', degree:'&#176;', zodiac:'&#9790;', house:'&#9751;', axis:'&#8597;', planetary:'&#9790;', minute:'&#8242;', second:'&#8243;', dimension:'&#9670;' },
            thought: { gate:'&#9733;', line:'&#9734;', color:'&#10038;', tone:'&#9836;', base:'&#9827;', degree:'&#176;', zodiac:'&#9789;', house:'&#9752;', axis:'&#8645;', planetary:'&#9789;', minute:'&#8242;', second:'&#8243;', dimension:'&#9672;' },
        };
        return (glyphs[centerKey] || glyphs.thought)[layerKey] || '&#9679;';
    }

    function brainAddTask(type, description, complexity, status) {
        brainState.tasks.push({
            id: brainState.nextTaskId++,
            type, description, complexity, status,
            createdAt: Date.now(),
        });
    }

    function brainApproveTask(taskId) {
        const task = brainState.tasks.find(t => t.id === taskId);
        if (!task || task.status !== 'pending') return;
        task.status = 'completed';
        const match = task.description.match(/"([^"]+)"/);
        if (match) {
            const item = brainState.items.find(i => i.name === match[1]);
            if (item && item.placement === 'shop') {
                brainState.shop = brainState.shop.filter(id => id !== item.id);
                item.placement = 'engine';
                brainState.engine.push(item.id);
            }
        }
        renderBrainTaskQueue();
        renderBrainShopEngine();
    }

    function brainDenyTask(taskId) {
        const task = brainState.tasks.find(t => t.id === taskId);
        if (!task || task.status !== 'pending') return;
        task.status = 'denied';
        renderBrainTaskQueue();
    }

    function brainMoveToEngine(itemId) {
        const item = brainState.items.find(i => i.id === itemId);
        if (!item) return;
        brainState.shop = brainState.shop.filter(id => id !== itemId);
        if (!brainState.engine.includes(itemId)) brainState.engine.push(itemId);
        item.placement = 'engine';
        renderBrainShopEngine();
    }

    function brainMoveToShop(itemId) {
        const item = brainState.items.find(i => i.id === itemId);
        if (!item) return;
        brainState.engine = brainState.engine.filter(id => id !== itemId);
        if (!brainState.shop.includes(itemId)) brainState.shop.push(itemId);
        item.placement = 'shop';
        renderBrainShopEngine();
    }

    function brainRecalcInterference() {
        const s = brainState.centers[0].activation;
        const e = brainState.centers[1].activation;
        const t = brainState.centers[2].activation;
        const pS = brainState.centers[0].phase;
        const pE = brainState.centers[1].phase;
        const pT = brainState.centers[2].phase;
        brainState.interference.SE = Math.abs(s * e * Math.cos(pS - pE));
        brainState.interference.ET = Math.abs(e * t * Math.cos(pE - pT));
        brainState.interference.TS = Math.abs(t * s * Math.cos(pT - pS));
        brainState.interference.total = (brainState.interference.SE + brainState.interference.ET + brainState.interference.TS) / 3;
    }

    function brainPulse() {
        brainState.pulseTime++;
        brainState.centers.forEach((c, i) => {
            c.phase += 0.2 + c.activation * 0.3;
            c.resonance = c.activation * Math.sin(c.phase) * 0.5 + 0.5;
            const otherActivations = brainState.centers.filter((_, j) => j !== i).map(o => o.activation);
            c.activation = Math.max(0.05, Math.min(1, c.activation + (otherActivations.reduce((a, b) => a + b, 0) / 2 - c.activation) * 0.05));
        });
        brainRecalcInterference();
        renderBrainCenterCards();
        renderBrainInterference();
        renderBrainGraph();
    }

    function brainRunResonance() {
        if (brainState.resonanceRunning) return;
        brainState.resonanceRunning = true;
        brainState.resonanceInterval = setInterval(() => brainPulse(), 350);
    }

    function brainStopResonance() {
        brainState.resonanceRunning = false;
        if (brainState.resonanceInterval) { clearInterval(brainState.resonanceInterval); brainState.resonanceInterval = null; }
    }

    function brainReset() {
        brainStopResonance();
        brainStopSync();
        brainState.centers.forEach(c => { c.activation = 0.33; c.resonance = 0; c.items = []; c.totalProcessed = 0; });
        brainState.interference = { SE: 0, ET: 0, TS: 0, total: 0 };
        brainState.items = [];
        brainState.shop = [];
        brainState.engine = [];
        brainState.tasks = [];
        brainState.nextItemId = 1;
        brainState.nextTaskId = 1;
        brainState.pulseTime = 0;
        brainState.selectedCenter = null;
        brainState.selectedItem = null;
        brainState.learningMemory = [];
        ragStore.documents = [];
        ragStore.embeddings.clear();
        ragStore.vocabulary.clear();
        ragStore.idfCache.clear();
        ragStore.totalDocs = 0;
        sensualProcessor.codeHistory = [];
        sensualProcessor.analysisResults.clear();
        mcpMemoryStore.clear();
        mcpRegistry.messageLog = [];
        mcpRegistry.nextMsgId = 1;
        renderBrainCenterCards();
        renderBrainInterference();
        renderBrainGraph();
        renderBrainTaskQueue();
        renderBrainShopEngine();
        renderBrainSubsystemBadges();
        renderBrainMCPList();
        document.getElementById('brainInfoPanel').innerHTML = '<h4>Select an awareness center or processed item</h4>';
        document.getElementById('brainRAGResults').innerHTML = '';
        brainTerminalClear();
        brainTermLog('[BRAIN] System reset. All subsystems cleared.', 'info');
        brainStartSync();
    }

    function brainProcessFiles() {
        if (state.files.length === 0) {
            alert('No files uploaded in the Upload tab yet. Upload files there first, or drop files directly into the Brain Knowledge Upload zone.');
            return;
        }
        const fakeFiles = state.files.map(f => ({
            name: f.name,
            text: () => Promise.resolve(f.content || ''),
        }));
        brainIngestFiles(fakeFiles);
    }

    function brainProcessToGraph() {
        const engineItems = brainState.engine.map(id => brainState.items.find(i => i.id === id)).filter(Boolean);
        if (engineItems.length === 0) {
            alert('No items in the Engine. Process files and approve them first.');
            return;
        }

        causalClear();
        const W = document.getElementById('causalGraphContainer').clientWidth || 900;
        const H = document.getElementById('causalGraphContainer').clientHeight || 500;

        const planetaryNode = causalAddNode('planetary', 'Brain Core', W * 0.08, H * 0.5);

        const dimLabels = ['Being','Evolution','Movement','Design','Space'];
        const dimNodes = [];
        for (let i = 0; i < 5; i++) {
            const dn = causalAddNode('dimension', dimLabels[i] + ' Field', W * 0.18, H * 0.15 + i * (H * 0.16));
            dimNodes.push(dn);
        }

        const centerNodes = [];
        BRAIN_PURPOSE.centers.forEach((center, ci) => {
            const cn = causalAddNode('axis', center.name, W * 0.12, H * 0.2 + ci * (H * 0.3));
            if (cn) {
                cn.color = center.color;
                cn.keynote = center.governance + ' / ' + center.role.toUpperCase();
                centerNodes.push(cn);
                causalState.edges.push({ sourceId: planetaryNode.id, targetId: cn.id, law: 'Law of Awareness', desc: 'Brain core activates ' + center.name });
                dimNodes.forEach(dn => {
                    causalState.edges.push({ sourceId: cn.id, targetId: dn.id, law: 'Law of Field Structuring', desc: center.name + ' shapes dimensional field' });
                });
            }
        });

        const fileNodes = [];
        const layerOrder = ['gate','line','color','tone','base','degree','minute','second','axis','zodiac','house'];
        const layerGroups = {};
        for (const item of engineItems) {
            if (!layerGroups[item.layerMapping]) layerGroups[item.layerMapping] = [];
            layerGroups[item.layerMapping].push(item);
        }

        for (const layerKey of layerOrder) {
            const group = layerGroups[layerKey] || [];
            const layerDef = CAUSAL_LAYERS.find(l => l.key === layerKey);
            if (!layerDef) continue;
            const colX = 0.3 + (layerDef.layerIndex / 13) * 0.6;
            for (let gi = 0; gi < group.length; gi++) {
                const item = group[gi];
                const shortName = item.name.split('/').pop();
                const label = shortName.length > 20 ? shortName.substring(0, 18) + '..' : shortName;
                const yPos = H * 0.08 + ((gi + 0.5) / Math.max(group.length, 1)) * H * 0.84;
                const node = causalAddNode(layerKey, label, W * colX, yPos);
                if (node) {
                    node.fileName = item.name;
                    node.value = 0.3 + (item.funcCount / Math.max(item.lineCount, 1)) * 3;
                    node.value = Math.min(1, node.value);
                    node.amplitude = 0.4 + item.centerScore[item.centerKey] * 0.6;
                    fileNodes.push({ node, item });

                    const centerNode = centerNodes[BRAIN_PURPOSE.centers.findIndex(c => c.key === item.centerKey)];
                    if (centerNode) {
                        causalState.edges.push({ sourceId: centerNode.id, targetId: node.id, law: 'Law of Awareness Processing', desc: item.centerKey + ' awareness processed ' + item.name });
                    }
                }
            }
        }

        for (let i = 0; i < fileNodes.length; i++) {
            const fnA = fileNodes[i];
            for (let j = i + 1; j < fileNodes.length; j++) {
                const fnB = fileNodes[j];
                const aImportsB = (fnA.item.imports || []).some(imp => {
                    const bBase = fnB.item.name.replace(/\.[^.]+$/, '').split('/').pop().toLowerCase();
                    return imp.toLowerCase().includes(bBase);
                });
                if (aImportsB) {
                    causalState.edges.push({ sourceId: fnA.node.id, targetId: fnB.node.id, law: 'Law of Import Dependency', desc: fnA.item.name + ' imports ' + fnB.item.name });
                }
            }
        }

        for (const fn of fileNodes) {
            const dimIdx = fn.item.isCode ? (fn.item.centerKey === 'thought' ? 2 : 0) : fn.item.isDoc ? 1 : fn.item.isConfig ? 3 : 4;
            if (dimNodes[dimIdx]) {
                causalState.edges.push({ sourceId: fn.node.id, targetId: dimNodes[dimIdx].id, law: 'Law of Field Structuring', desc: fn.item.name + ' feeds ' + dimLabels[dimIdx] + ' field' });
            }
        }

        initStateFromGraph();
        renderCausalGraph();
        updateSimReadout();

        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        document.querySelector('[data-tab="causal"]').classList.add('active');
        document.getElementById('causal').classList.add('active');
        document.querySelectorAll('.mobile-tab-option').forEach(o => {
            o.classList.toggle('active', o.dataset.tab === 'causal');
        });
        const mobileLabel = document.getElementById('mobileTabLabel');
        if (mobileLabel) mobileLabel.textContent = 'Causal Engine';
        setTimeout(() => renderCausalGraph(), 200);
    }

    function renderBrainCenterCards() {
        const container = document.getElementById('brainCenterCards');
        container.innerHTML = BRAIN_PURPOSE.centers.map((center, i) => {
            const cs = brainState.centers[i];
            const isActive = brainState.selectedCenter === center.key;
            return `
                <div class="brain-center-card ${isActive ? 'active' : ''}" onclick="brainSelectCenter('${center.key}')" style="border-left:4px solid ${center.color};">
                    <div class="brain-center-title" style="color:${center.color};">${center.icon} ${center.name}</div>
                    <div class="brain-center-subtitle">${center.governance} | ${center.role.toUpperCase()}</div>
                    <div style="font-size:0.8em;color:#8b8fce;">${center.desc}</div>
                    <div style="display:flex;gap:12px;margin-top:6px;font-size:0.8em;">
                        <span style="color:#818cf8;">Activation: ${(cs.activation * 100).toFixed(1)}%</span>
                        <span style="color:#8b8fce;">Items: ${cs.items.length}</span>
                    </div>
                    <div class="brain-center-meter"><div class="brain-center-meter-fill" style="width:${cs.activation * 100}%;background:${center.color};"></div></div>
                </div>
            `;
        }).join('');
    }

    function brainSelectCenter(key) {
        brainState.selectedCenter = key;
        const center = BRAIN_PURPOSE.centers.find(c => c.key === key);
        const cs = brainState.centers.find(c => c.key === key);
        const items = cs.items.map(id => brainState.items.find(i => i.id === id)).filter(Boolean);
        const panel = document.getElementById('brainInfoPanel');

        let subsystemInfo = '';
        if (key === 'sensual') {
            const analysisCount = sensualProcessor.analysisResults.size;
            const pyReady = state.pyodideReady;
            subsystemInfo = `
                <div style="margin-top:8px;padding:6px;background:#1a1000;border:1px solid #553300;">
                    <div style="color:#f59e0b;font-weight:bold;font-size:0.85em;">Pyodide Deterministic Engine</div>
                    <div style="font-size:0.78em;color:#8a6a30;">Runtime: ${pyReady ? 'READY' : 'LOADING'} | Analyses: ${analysisCount} | History: ${sensualProcessor.codeHistory.length}</div>
                    <div style="font-size:0.75em;color:#664400;margin-top:2px;">Capabilities: ${Array.from(sensualProcessor.capabilities).join(', ')}</div>
                </div>`;
        } else if (key === 'emotional') {
            subsystemInfo = `
                <div style="margin-top:8px;padding:6px;background:#1a0020;border:1px solid #553355;">
                    <div style="color:#f472b6;font-weight:bold;font-size:0.85em;">RAG Adaptive Retrieval</div>
                    <div style="font-size:0.78em;color:#884466;">Documents: ${ragStore.totalDocs} | Vocab: ${ragStore.vocabulary.size} | Embeddings: ${ragStore.embeddings.size}</div>
                    <div style="font-size:0.75em;color:#5a2d50;margin-top:2px;">TF-IDF vectorization with cosine similarity search</div>
                </div>`;
        } else if (key === 'thought') {
            const protocols = Array.from(mcpRegistry.protocols.values());
            const connected = protocols.filter(p => p.status === 'connected').length;
            const totalMsgs = mcpRegistry.messageLog.length;
            subsystemInfo = `
                <div style="margin-top:8px;padding:6px;background:#001a30;border:1px solid #335588;">
                    <div style="color:#38bdf8;font-weight:bold;font-size:0.85em;">MCP Protocol Connector</div>
                    <div style="font-size:0.78em;color:#446688;">Protocols: ${connected}/${protocols.length} connected | Messages: ${totalMsgs}</div>
                    <div style="font-size:0.75em;color:#334466;margin-top:2px;">${protocols.map(p => p.name).join(', ')}</div>
                </div>`;
        }

        panel.innerHTML = `
            <h4 style="color:${center.color};">${center.icon} ${center.name}</h4>
            <div class="brain-info-row"><span class="brain-info-key">Governance</span><span class="brain-info-val">${center.governance}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Role</span><span class="brain-info-val">${center.role.toUpperCase()}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Activation</span><span class="brain-info-val" style="color:${center.color};">${(cs.activation * 100).toFixed(1)}%</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Resonance</span><span class="brain-info-val" style="color:${center.color};">${(cs.resonance * 100).toFixed(1)}%</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Phase</span><span class="brain-info-val">${cs.phase.toFixed(3)}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Items</span><span class="brain-info-val">${cs.items.length}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Total Processed</span><span class="brain-info-val">${cs.totalProcessed}</span></div>
            ${subsystemInfo}
            ${items.length ? '<div style="margin-top:8px;color:#818cf8;font-size:0.85em;">Processed Files:</div>' + items.map(it =>
                `<div style="color:#a5b4fc;font-size:0.8em;padding:2px 0;cursor:pointer;" onclick="brainSelectItem(${it.id})">${it.glyph} ${escapeHtml(it.name)} <span style="color:#5558a0;">[${it.layerMapping}]</span></div>`
            ).join('') : ''}
        `;
        renderBrainCenterCards();
        renderBrainGraph();
    }

    function brainSelectItem(itemId) {
        const item = brainState.items.find(i => i.id === itemId);
        if (!item) return;
        brainState.selectedItem = itemId;
        const panel = document.getElementById('brainInfoPanel');
        const center = BRAIN_PURPOSE.centers.find(c => c.key === item.centerKey);
        panel.innerHTML = `
            <h4 style="color:${center.color};">${item.glyph} ${escapeHtml(item.name)}</h4>
            <div class="brain-info-row"><span class="brain-info-key">Address</span><span class="brain-info-val" style="font-size:0.75em;">${item.address.full}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Layer</span><span class="brain-info-val">${item.layerMapping}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Center</span><span class="brain-info-val" style="color:${center.color};">${center.name}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Placement</span><span class="brain-info-val" style="color:${item.placement === 'engine' ? '#34d399' : '#f59e0b'};">${item.placement === 'engine' ? 'ENGINE' : 'SHOP'}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Lines</span><span class="brain-info-val">${item.lineCount}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Words</span><span class="brain-info-val">${item.wordCount}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Functions</span><span class="brain-info-val">${item.funcCount}</span></div>
            <div class="brain-info-row"><span class="brain-info-key">Type</span><span class="brain-info-val">${item.isCode ? 'Code' : item.isDoc ? 'Document' : item.isConfig ? 'Config' : 'Markup'}</span></div>
            <div style="margin-top:6px;font-size:0.78em;color:#5558a0;">
                S: ${(item.centerScore.sensual * 100).toFixed(0)}% | E: ${(item.centerScore.emotional * 100).toFixed(0)}% | T: ${(item.centerScore.thought * 100).toFixed(0)}%
            </div>
            ${(() => {
                const analysis = sensualProcessor.analysisResults.get(item.id);
                if (analysis) {
                    return `<div style="margin-top:8px;padding:6px;background:#141728;border:1px solid #2a2d50;">
                        <div style="color:#f59e0b;font-weight:bold;font-size:0.8em;">Pyodide Analysis ${analysis.deterministic ? '(deterministic)' : '(JS fallback)'}</div>
                        <div style="font-size:0.75em;color:#8a6a30;">Structure: ${analysis.structure_type} | Complexity: ${analysis.complexity_score}/10</div>
                        <div style="font-size:0.75em;color:#5558a0;">Loops: ${analysis.has_loops ? 'Yes' : 'No'} | Conditionals: ${analysis.has_conditionals ? 'Yes' : 'No'} | Error handling: ${analysis.has_error_handling ? 'Yes' : 'No'}</div>
                    </div>`;
                }
                return '';
            })()}
            <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap;">
                ${item.placement === 'shop' ? `<button onclick="brainMoveToEngine(${item.id})" style="padding:4px 10px;font-size:0.8em;background:#2a5a4a;border-color:#34d399;color:#fff;">Move to Engine</button>` : ''}
                ${item.placement === 'engine' ? `<button onclick="brainMoveToShop(${item.id})" style="padding:4px 10px;font-size:0.8em;background:#8a6a30;border-color:#f59e0b;color:#fff;">Move to Shop</button>` : ''}
                <button onclick="brainRunPyodideAnalysis(brainState.items.find(i=>i.id===${item.id})).then(()=>brainSelectItem(${item.id}))" style="padding:4px 10px;font-size:0.8em;background:#1a1540;border-color:#6366f1;color:#818cf8;margin:0;">Re-analyze</button>
            </div>
        `;
    }

    function renderBrainInterference() {
        const readout = document.getElementById('brainInterferenceReadout');
        const pairs = [
            { label: 'Sensual-Emotional (S-E)', value: brainState.interference.SE, color: '#ff7744' },
            { label: 'Emotional-Thought (E-T)', value: brainState.interference.ET, color: '#aa44ff' },
            { label: 'Thought-Sensual (T-S)', value: brainState.interference.TS, color: '#44ccff' },
        ];
        readout.innerHTML = pairs.map(p => `
            <div class="interference-row">
                <span class="interference-label">${p.label}</span>
                <div class="interference-bar"><div class="interference-bar-fill" style="width:${p.value * 100}%;background:${p.color};"></div></div>
                <span class="interference-value" style="color:${p.color};">${(p.value * 100).toFixed(1)}%</span>
            </div>
        `).join('') + `
            <div class="interference-row" style="margin-top:6px;border-top:1px solid #332244;padding-top:6px;">
                <span class="interference-label" style="color:#818cf8;">Total Coherence</span>
                <div class="interference-bar"><div class="interference-bar-fill" style="width:${brainState.interference.total * 100}%;background:#818cf8;"></div></div>
                <span class="interference-value" style="color:#818cf8;">${(brainState.interference.total * 100).toFixed(1)}%</span>
            </div>
        `;
    }

    function renderBrainTaskQueue() {
        const container = document.getElementById('brainTaskQueue');
        const count = document.getElementById('brainTaskCount');
        const pending = brainState.tasks.filter(t => t.status === 'pending');
        count.textContent = `(${pending.length} pending)`;
        if (brainState.tasks.length === 0) {
            container.innerHTML = '<div style="color:#5558a0;font-size:0.85em;padding:8px;">No tasks yet</div>';
            return;
        }
        container.innerHTML = brainState.tasks.slice(-20).reverse().map(t => {
            const statusColor = t.status === 'completed' ? '#34d399' : t.status === 'pending' ? '#f59e0b' : '#ef4444';
            const isApproval = t.status === 'pending' && t.type === 'approval';
            return `
                <div style="padding:6px 8px;border-bottom:1px solid #1a1d40;font-size:0.82em;">
                    <div style="display:flex;justify-content:space-between;align-items:center;gap:6px;">
                        <span style="color:${statusColor};font-size:0.75em;text-transform:uppercase;">[${t.status}]</span>
                        <span style="color:#a5b4fc;flex:1;">${escapeHtml(t.description)}</span>
                        <span style="color:#5558a0;font-size:0.75em;">${t.complexity}/10</span>
                    </div>
                    ${isApproval ? `<div style="margin-top:4px;"><button onclick="brainApproveTask(${t.id})" style="padding:2px 8px;font-size:0.75em;background:#2a5a4a;border-color:#34d399;color:#fff;margin:0;">Approve</button> <button onclick="brainDenyTask(${t.id})" style="padding:2px 8px;font-size:0.75em;margin:0;" class="danger">Deny</button></div>` : ''}
                </div>
            `;
        }).join('');
    }

    function renderBrainShopEngine() {
        const shopList = document.getElementById('brainShopList');
        const engineList = document.getElementById('brainEngineList');
        const shopItems = brainState.shop.map(id => brainState.items.find(i => i.id === id)).filter(Boolean);
        const engineItems = brainState.engine.map(id => brainState.items.find(i => i.id === id)).filter(Boolean);

        shopList.innerHTML = shopItems.length ? shopItems.map(it => {
            const center = BRAIN_PURPOSE.centers.find(c => c.key === it.centerKey);
            return `<div class="brain-doc-item" onclick="brainSelectItem(${it.id})" style="border-left-color:${center.color};">
                <span style="color:${center.color};">${it.glyph}</span>
                <span style="flex:1;color:#a5b4fc;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(it.name)}</span>
                <button onclick="event.stopPropagation();brainMoveToEngine(${it.id})" style="padding:2px 6px;font-size:0.7em;margin:0;background:#2a5a4a;border-color:#34d399;color:#fff;">&#8594; Engine</button>
            </div>`;
        }).join('') : '<div style="color:#5558a0;font-size:0.8em;padding:6px;">Empty</div>';

        engineList.innerHTML = engineItems.length ? engineItems.map(it => {
            const center = BRAIN_PURPOSE.centers.find(c => c.key === it.centerKey);
            return `<div class="brain-doc-item" onclick="brainSelectItem(${it.id})" style="border-left-color:${center.color};">
                <span style="color:${center.color};">${it.glyph}</span>
                <span style="flex:1;color:#a5b4fc;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(it.name)}</span>
                <span class="brain-doc-center-badge" style="color:${center.color};border-color:${center.color};">${it.layerMapping}</span>
            </div>`;
        }).join('') : '<div style="color:#5558a0;font-size:0.8em;padding:6px;">Empty</div>';
    }

    function renderBrainGraph() {
        const container = document.getElementById('brainContainer');
        const width = container.clientWidth || 900;
        const height = container.clientHeight || 500;

        d3.select('#brainSvg').selectAll('*').remove();
        const svg = d3.select('#brainSvg').attr('width', width).attr('height', height);
        const g = svg.append('g');

        brainZoomBehavior = d3.zoom().scaleExtent([0.3, 5]).on('zoom', (e) => g.attr('transform', e.transform));
        svg.call(brainZoomBehavior);
        brainSvgSel = svg;

        const defs = svg.append('defs');
        const brainGlow = defs.append('filter').attr('id', 'brain-glow');
        brainGlow.append('feGaussianBlur').attr('stdDeviation', '4').attr('result', 'blur');
        brainGlow.append('feMerge').selectAll('feMergeNode').data(['blur', 'SourceGraphic']).join('feMergeNode').attr('in', d => d);

        const centerGlow = defs.append('filter').attr('id', 'center-glow');
        centerGlow.append('feGaussianBlur').attr('stdDeviation', '8').attr('result', 'blur');
        centerGlow.append('feMerge').selectAll('feMergeNode').data(['blur', 'SourceGraphic']).join('feMergeNode').attr('in', d => d);

        defs.append('marker').attr('id', 'brain-arrow').attr('viewBox', '-0 -5 10 10')
            .attr('refX', 20).attr('refY', 0).attr('orient', 'auto')
            .attr('markerWidth', 6).attr('markerHeight', 6)
            .append('path').attr('d', 'M 0,-3 L 6,0 L 0,3').attr('fill', '#6366f1');

        const cx = width / 2;
        const cy = height / 2;
        const triRadius = Math.min(width, height) * 0.32;

        const centerPositions = BRAIN_PURPOSE.centers.map((center, i) => {
            const angle = -Math.PI / 2 + (i * Math.PI * 2 / 3);
            return { x: cx + Math.cos(angle) * triRadius, y: cy + Math.sin(angle) * triRadius, center, idx: i };
        });

        const purposeText = g.append('text')
            .attr('x', cx).attr('y', cy + triRadius + 50)
            .attr('text-anchor', 'middle').attr('fill', '#2a2d50').attr('font-size', '9px')
            .attr('font-family', 'Courier New')
            .text(BRAIN_PURPOSE.core.substring(0, 80) + '...');

        for (let i = 0; i < 3; i++) {
            const j = (i + 1) % 3;
            const cs1 = brainState.centers[i];
            const cs2 = brainState.centers[j];
            const interKey = i === 0 ? 'SE' : i === 1 ? 'ET' : 'TS';
            const interVal = brainState.interference[interKey];
            g.append('line')
                .attr('x1', centerPositions[i].x).attr('y1', centerPositions[i].y)
                .attr('x2', centerPositions[j].x).attr('y2', centerPositions[j].y)
                .attr('stroke', BRAIN_PURPOSE.centers[i].color)
                .attr('stroke-width', 1 + interVal * 4)
                .attr('stroke-opacity', 0.2 + interVal * 0.5)
                .attr('stroke-dasharray', brainState.resonanceRunning ? '8,4' : 'none');

            const midX = (centerPositions[i].x + centerPositions[j].x) / 2;
            const midY = (centerPositions[i].y + centerPositions[j].y) / 2;
            g.append('text')
                .attr('x', midX).attr('y', midY - 6)
                .attr('text-anchor', 'middle').attr('fill', '#5558a0').attr('font-size', '8px')
                .attr('font-family', 'Courier New')
                .text((interVal * 100).toFixed(0) + '%');
        }

        const innerTriRadius = triRadius * 0.15;
        const innerPoints = centerPositions.map(cp => {
            const dx = cx - cp.x;
            const dy = cy - cp.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return { x: cp.x + dx * 0.7, y: cp.y + dy * 0.7 };
        });

        if (brainState.interference.total > 0.1) {
            g.append('polygon')
                .attr('points', innerPoints.map(p => `${p.x},${p.y}`).join(' '))
                .attr('fill', `rgba(99,102,241,${brainState.interference.total * 0.15})`)
                .attr('stroke', '#6366f1')
                .attr('stroke-width', 1)
                .attr('stroke-opacity', brainState.interference.total * 0.5);
        }

        g.append('circle')
            .attr('cx', cx).attr('cy', cy)
            .attr('r', 12 + brainState.interference.total * 8)
            .attr('fill', '#1a1d40')
            .attr('stroke', '#6366f1')
            .attr('stroke-width', 2)
            .attr('filter', 'url(#brain-glow)')
            .attr('opacity', 0.5 + brainState.interference.total * 0.5);

        g.append('text')
            .attr('x', cx).attr('y', cy + 4)
            .attr('text-anchor', 'middle').attr('fill', '#818cf8').attr('font-size', '10px')
            .attr('font-family', 'Courier New').attr('font-weight', 'bold')
            .text('CORE');

        const tooltip = document.getElementById('brainTooltip');

        centerPositions.forEach((cp, i) => {
            const center = cp.center;
            const cs = brainState.centers[i];
            const baseR = 28 + cs.activation * 20;
            const pulseR = brainState.resonanceRunning ? baseR + Math.sin(cs.phase) * 6 : baseR;

            if (brainState.resonanceRunning) {
                g.append('circle')
                    .attr('cx', cp.x).attr('cy', cp.y)
                    .attr('r', pulseR + 10 + Math.sin(cs.phase * 0.5) * 5)
                    .attr('fill', 'none')
                    .attr('stroke', center.color)
                    .attr('stroke-width', 1)
                    .attr('opacity', 0.2 + cs.resonance * 0.3);
            }

            g.append('circle')
                .attr('cx', cp.x).attr('cy', cp.y)
                .attr('r', pulseR)
                .attr('fill', center.color)
                .attr('fill-opacity', 0.15 + cs.activation * 0.2)
                .attr('stroke', center.color)
                .attr('stroke-width', brainState.selectedCenter === center.key ? 3 : 2)
                .attr('filter', 'url(#center-glow)')
                .style('cursor', 'pointer')
                .on('click', () => brainSelectCenter(center.key))
                .on('mouseover', (e) => {
                    tooltip.style.display = 'block';
                    const rect = container.getBoundingClientRect();
                    tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
                    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
                    tooltip.innerHTML = `
                        <div style="color:${center.color};font-weight:bold;margin-bottom:4px;">${center.icon} ${center.name}</div>
                        <div style="color:#8b8fce;">Governance: ${center.governance}</div>
                        <div style="color:#8b8fce;">Role: ${center.role.toUpperCase()}</div>
                        <div style="color:#818cf8;margin-top:4px;">Activation: ${(cs.activation * 100).toFixed(1)}%</div>
                        <div style="color:#818cf8;">Items: ${cs.items.length}</div>
                        <div style="color:#5558a0;margin-top:4px;font-size:0.9em;">${center.desc}</div>
                    `;
                })
                .on('mouseout', () => { tooltip.style.display = 'none'; });

            g.append('text')
                .attr('x', cp.x).attr('y', cp.y + 4)
                .attr('text-anchor', 'middle').attr('fill', center.color).attr('font-size', '14px')
                .attr('font-family', 'Courier New').attr('font-weight', 'bold')
                .attr('pointer-events', 'none')
                .text(center.icon);

            g.append('text')
                .attr('x', cp.x).attr('y', cp.y + pulseR + 16)
                .attr('text-anchor', 'middle').attr('fill', center.color).attr('font-size', '9px')
                .attr('font-family', 'Courier New')
                .text(center.name);

            g.append('text')
                .attr('x', cp.x).attr('y', cp.y + pulseR + 28)
                .attr('text-anchor', 'middle').attr('fill', '#5558a0').attr('font-size', '7px')
                .attr('font-family', 'Courier New')
                .text(center.governance);

            const items = cs.items.map(id => brainState.items.find(it => it.id === id)).filter(Boolean);
            const orbitR = pulseR + 35;
            items.forEach((item, ii) => {
                const angle = (ii / Math.max(items.length, 1)) * Math.PI * 2 - Math.PI / 2;
                const ix = cp.x + Math.cos(angle) * orbitR;
                const iy = cp.y + Math.sin(angle) * orbitR;

                g.append('line')
                    .attr('x1', cp.x).attr('y1', cp.y)
                    .attr('x2', ix).attr('y2', iy)
                    .attr('stroke', center.color).attr('stroke-width', 0.5).attr('stroke-opacity', 0.3);

                const itemR = 5 + (item.placement === 'engine' ? 2 : 0);
                g.append('circle')
                    .attr('cx', ix).attr('cy', iy)
                    .attr('r', itemR)
                    .attr('fill', item.placement === 'engine' ? center.color : '#332244')
                    .attr('stroke', center.color)
                    .attr('stroke-width', 1)
                    .attr('opacity', item.placement === 'engine' ? 0.8 : 0.4)
                    .attr('filter', 'url(#brain-glow)')
                    .style('cursor', 'pointer')
                    .on('click', () => brainSelectItem(item.id))
                    .on('mouseover', (e) => {
                        tooltip.style.display = 'block';
                        const rect = container.getBoundingClientRect();
                        tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
                        tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
                        tooltip.innerHTML = `
                            <div style="color:${center.color};font-weight:bold;">${item.glyph} ${escapeHtml(item.name)}</div>
                            <div style="color:#8b8fce;">${item.address.full}</div>
                            <div style="color:#818cf8;">Layer: ${item.layerMapping} | ${item.placement === 'engine' ? 'ENGINE' : 'SHOP'}</div>
                        `;
                    })
                    .on('mouseout', () => { tooltip.style.display = 'none'; });

                g.append('text')
                    .attr('x', ix).attr('y', iy + itemR + 10)
                    .attr('text-anchor', 'middle').attr('fill', '#5558a0').attr('font-size', '6px')
                    .attr('font-family', 'Courier New')
                    .text(item.name.length > 12 ? item.name.substring(0, 10) + '..' : item.name);
            });
        });
    }

    function brainZoom(factor) {
        if (brainSvgSel && brainZoomBehavior) brainSvgSel.transition().duration(300).call(brainZoomBehavior.scaleBy, factor);
    }

    // Initial render
    renderUploadedFiles();
    renderStylePresets();
    causalInit();
    brainInit();
    </script>

    <!-- ===== MODULE SYSTEM ===== -->
    <script>
    let modStagedFiles = [];

    function handleModDrop(e) {
        e.preventDefault();
        document.getElementById('modDropZone').style.borderColor = '#3b82f6';
        handleModFiles(e.dataTransfer.files);
    }

    function handleModFiles(fileList) {
        for (const f of fileList) modStagedFiles.push(f);
        renderModFileList();
    }

    function renderModFileList() {
        const el = document.getElementById('modFileList');
        if (!modStagedFiles.length) { el.innerHTML = ''; return; }
        el.innerHTML = modStagedFiles.map((f,i) =>
            `<span style="display:inline-flex;align-items:center;gap:4px;margin:2px 4px 2px 0;padding:3px 8px;background:#12151e;border:1px solid #3b82f6;border-radius:4px">
                ${f.name} <span onclick="removeModFile(${i})" style="cursor:pointer;color:#ef4444;margin-left:4px">×</span>
            </span>`
        ).join('');
    }

    function removeModFile(i) {
        modStagedFiles.splice(i, 1);
        renderModFileList();
    }

    async function buildModule() {
        const name = document.getElementById('modName').value.trim();
        const desc = document.getElementById('modDescription').value.trim();
        const icon = document.getElementById('modIcon').value.trim() || '🔷';
        if (!name) { alert('Give your module a name first.'); return; }

        const logEl = document.getElementById('modBuildLog');
        const outputEl = document.getElementById('modBuildOutput');
        outputEl.style.display = 'block';
        logEl.textContent = '';
        function log(msg) { logEl.textContent += msg + '\n'; logEl.scrollTop = logEl.scrollHeight; }

        log(`Building: ${name}...`);

        let fileContents = [];
        for (const f of modStagedFiles) {
            log(`Reading: ${f.name}`);
            try {
                if (f.name.endsWith('.zip')) {
                    const zip = new JSZip();
                    const z = await zip.loadAsync(f);
                    for (const [path, entry] of Object.entries(z.files)) {
                        if (!entry.dir) {
                            const content = await entry.async('string').catch(() => '[binary]');
                            fileContents.push({ name: path, content });
                        }
                    }
                } else if (f.name.endsWith('.gz') || f.name.endsWith('.tar.gz')) {
                    log(`  tar.gz detected — extracting via JSZip`);
                    const buf = await f.arrayBuffer();
                    try {
                        const zip = new JSZip();
                        const z = await zip.loadAsync(buf);
                        for (const [path, entry] of Object.entries(z.files)) {
                            if (!entry.dir) {
                                const content = await entry.async('string').catch(() => '[binary]');
                                fileContents.push({ name: path, content });
                            }
                        }
                    } catch(e2) { log(`  could not extract: ${e2.message}`); }
                } else {
                    const content = await f.text().catch(() => '[binary]');
                    fileContents.push({ name: f.name, content });
                }
            } catch(e) { log(`  skipped: ${e.message}`); }
        }
        log(`Files ingested: ${fileContents.length}`);

        let entryHTML = '';
        const htmlFile = fileContents.find(f => f.name.match(/index\.html$/i))
                      || fileContents.find(f => f.name.match(/\.html$/i));

        if (htmlFile) {
            entryHTML = htmlFile.content;
            log(`Entry: ${htmlFile.name}`);
        } else if (fileContents.length > 0) {
            const fileItems = fileContents.slice(0,20).map(f =>
                `<div style="margin-bottom:16px">
                    <div style="color:#60a5fa;font-size:0.85em;margin-bottom:4px;border-bottom:1px solid #1a1a3e;padding-bottom:4px">${f.name}</div>
                    <pre style="white-space:pre-wrap;word-break:break-all;font-size:0.78em;color:#c0d0ff;background:#12151e;padding:8px;border-radius:4px;max-height:180px;overflow-y:auto">${(f.content||'').substring(0,2000)}${(f.content||'').length>2000?'\n[truncated...]':''}</pre>
                </div>`
            ).join('');
            entryHTML = `<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>${name}</title>
            <style>body{margin:0;background:#0c0e14;color:#c0d0ff;font-family:monospace;padding:16px}h1{color:#60a5fa}p{color:#3b82f6;font-size:0.85em;margin-bottom:20px}</style>
            </head><body><h1>${icon} ${name}</h1><p>${desc}</p>${fileItems}</body></html>`;
            log('Built file viewer');
        } else {
            entryHTML = `<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>${name}</title>
            <style>body{margin:0;background:#0c0e14;color:#c0d0ff;font-family:system-ui;display:flex;align-items:center;justify-content:center;min-height:100vh;flex-direction:column;text-align:center;padding:24px}
            .icon{font-size:4em;margin-bottom:16px}.title{font-size:1.8em;color:#60a5fa;margin-bottom:8px}.desc{color:#3b82f6;max-width:500px;line-height:1.6}
            .badge{display:inline-block;margin-top:20px;padding:8px 20px;border:1px solid #3b82f6;border-radius:20px;color:#3b82f6;font-size:0.85em}</style>
            </head><body><div class="icon">${icon}</div><div class="title">${name}</div><div class="desc">${desc||'Ready for content'}</div>
            <div class="badge">Module ready — connect your AI or add files</div></body></html>`;
            log('Built placeholder module');
        }

        const modules = JSON.parse(localStorage.getItem('younivirse_modules') || '[]');
        modules.unshift({ id: Date.now().toString(), name, desc, icon, html: entryHTML, ai: '', created: new Date().toISOString(), fileCount: fileContents.length });
        localStorage.setItem('younivirse_modules', JSON.stringify(modules));

        log(`✓ Saved to My Apps`);
        modStagedFiles = [];
        renderModFileList();
        document.getElementById('modName').value = '';
        document.getElementById('modDescription').value = '';
        document.getElementById('modIcon').value = '';
    }

    function loadMyApps() {
        const modules = JSON.parse(localStorage.getItem('younivirse_modules') || '[]');
        const list = document.getElementById('myAppsList');
        const empty = document.getElementById('myAppsEmpty');
        if (!modules.length) { list.innerHTML = ''; empty.style.display = 'block'; return; }
        empty.style.display = 'none';
        list.innerHTML = modules.map(m => `
            <div style="background:#12151e;border:1px solid #1a3a5e;border-radius:8px;padding:16px">
                <div style="font-size:2em;margin-bottom:8px">${m.icon}</div>
                <div style="color:#60a5fa;font-weight:bold;margin-bottom:4px">${m.name}</div>
                <div style="color:#3b82f6;font-size:0.78em;margin-bottom:12px;line-height:1.4">${(m.desc||'').substring(0,100)}${(m.desc||'').length>100?'...':''}</div>
                <div style="font-size:0.75em;color:#1a5a8e;margin-bottom:12px">📁 ${m.fileCount} files · ${new Date(m.created).toLocaleDateString()}${m.ai?' · 🤖 '+m.ai:''}</div>
                <div style="display:flex;gap:6px">
                    <button onclick="openModule('${m.id}')" style="flex:1;padding:8px;background:linear-gradient(135deg,#0d1a3e,#0d2a4e);border:1px solid #3b82f6;color:#60a5fa;border-radius:6px;cursor:pointer;font-size:0.82em">▶ Open</button>
                    <button onclick="deleteModule('${m.id}',event)" style="padding:8px 12px;background:#12151e;border:1px solid #4a1a1a;color:#ef4444;border-radius:6px;cursor:pointer;font-size:0.82em">✕</button>
                </div>
            </div>`).join('');
    }

    function openModule(id) {
        const modules = JSON.parse(localStorage.getItem('younivirse_modules') || '[]');
        const mod = modules.find(m => m.id === id);
        if (!mod) return;
        document.getElementById('overlayTitle').textContent = `${mod.icon} ${mod.name}`;
        document.getElementById('overlayAISelect').value = mod.ai || '';
        document.getElementById('overlayAICustom').style.display = mod.ai === 'custom' ? 'block' : 'none';
        document.getElementById('moduleFrame').srcdoc = mod.html;
        const overlay = document.getElementById('moduleOverlay');
        overlay.style.display = 'flex';
        overlay._currentId = id;
    }

    function closeModule() {
        document.getElementById('moduleOverlay').style.display = 'none';
        document.getElementById('moduleFrame').srcdoc = '';
    }

    function saveModuleAI() {
        const id = document.getElementById('moduleOverlay')._currentId;
        const ai = document.getElementById('overlayAISelect').value;
        document.getElementById('overlayAICustom').style.display = ai === 'custom' ? 'block' : 'none';
        const modules = JSON.parse(localStorage.getItem('younivirse_modules') || '[]');
        const mod = modules.find(m => m.id === id);
        if (mod) { mod.ai = ai; localStorage.setItem('younivirse_modules', JSON.stringify(modules)); }
    }

    function deleteModule(id, e) {
        e.stopPropagation();
        if (!confirm('Remove this module?')) return;
        const modules = JSON.parse(localStorage.getItem('younivirse_modules') || '[]');
        localStorage.setItem('younivirse_modules', JSON.stringify(modules.filter(m => m.id !== id)));
        loadMyApps();
    }

    async function exportAllModules() {
        const modules = JSON.parse(localStorage.getItem('younivirse_modules') || '[]');
        if (!modules.length) { alert('No modules to export.'); return; }
        const zip = new JSZip();
        for (const m of modules) {
            const safe = m.name.replace(/[^a-z0-9]/gi,'_').toLowerCase();
            zip.file(`${safe}/index.html`, m.html);
            zip.file(`${safe}/module.json`, JSON.stringify({name:m.name,desc:m.desc,icon:m.icon,ai:m.ai,created:m.created},null,2));
        }
        const blob = await zip.generateAsync({type:'blob'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'younivirse_modules.zip';
        a.click();
    }

    function clearAllModules() {
        if (!confirm('Clear ALL modules? Cannot be undone.')) return;
        localStorage.removeItem('younivirse_modules');
        loadMyApps();
    }

    // Refresh My Apps whenever that tab is clicked
    document.querySelectorAll('[data-tab="myapps"]').forEach(btn =>
        btn.addEventListener('click', loadMyApps)
    );
    loadMyApps();
    </script>
</body>
</html>
