                    
                    const files = [];
                    let completed = 0;
                    
                    storeNames.forEach(storeName => {
                        const transaction = this.db.transaction([storeName], 'readonly');
                        const store = transaction.objectStore(storeName);
                        const request = store.getAll();
                        
                        request.onsuccess = () => {
                            let results = request.result;
                            
                            // Filter by userGlyph if specified
                            if (userGlyph && storeName === 'personal_files') {
                                results = results.filter(f => f.userGlyph === userGlyph);
                            }
                            
                            files.push(...results);
                            completed++;
                            
                            if (completed === storeNames.length) {
                                resolve(files);
                            }
                        };
                        
                        request.onerror = () => reject(request.error);
                    });
                });
            },
            
            // Get single file
            async getFile(id, category = 'canonical') {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    const storeName = category === 'personal' ? 'personal_files' : 
                                    (category === 'agent' ? 'agent_files' : 'canonical_files');
                    
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(id);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            
            // Delete file
            async deleteFile(id, category = 'canonical') {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    const storeName = category === 'personal' ? 'personal_files' : 
                                    (category === 'agent' ? 'agent_files' : 'canonical_files');
                    
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(id);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            },
            
            // Download file
            downloadFile(fileData) {
                const blob = new Blob([fileData.data], { type: fileData.type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileData.filename;
                a.click();
                URL.revokeObjectURL(url);
            },
            
            // Get file stats
            async getStats() {
                const files = await this.getAllFiles();
                
                const stats = {
                    total: files.length,
                    totalSize: files.reduce((sum, f) => sum + f.size, 0),
                    byCategory: {},
                    byType: {}
                };
                
                files.forEach(file => {
                    // By category
                    if (!stats.byCategory[file.category]) {
                        stats.byCategory[file.category] = { count: 0, size: 0 };
                    }
                    stats.byCategory[file.category].count++;
                    stats.byCategory[file.category].size += file.size;
                    
                    // By type
                    const mainType = file.type.split('/')[0] || 'unknown';
                    if (!stats.byType[mainType]) {
                        stats.byType[mainType] = { count: 0, size: 0 };
                    }
                    stats.byType[mainType].count++;
                    stats.byType[mainType].size += file.size;
                });
                
                stats.totalSizeMB = (stats.totalSize / 1024 / 1024).toFixed(2);
                
                return stats;
            }
        };
        
        const MCPMaintenanceLayer = {
            prefix: 'mcp_',
            
            // MCP Maintenance Agents (D4 dimension)
            agents: {
                system_health_monitor: {
                    address: 'D4 // 1.1.1.1.1 // 0¬∞0\'0" // 0.0-AR-H1 // U // 20260101-0000-MCP',
                    glyph: 'üè•',
                    role: 'Monitor system health',
                    capabilities: ['check_storage', 'measure_performance', 'detect_corruption']
                },
                data_integrity_checker: {
                    address: 'D4 // 2.2.2.2.2 // 5¬∞5\'5" // 10.0-TA-H2 // U // 20260101-0000-MCP',
                    glyph: 'üîç',
                    role: 'Verify data integrity',
                    capabilities: ['validate_addresses', 'check_glyphs', 'verify_relationships']
                },
                performance_optimizer: {
                    address: 'D4 // 3.3.3.3.3 // 10¬∞10\'10" // 20.0-GE-H3 // U // 20260101-0000-MCP',
                    glyph: '‚ö°',
                    role: 'Optimize performance',
                    capabilities: ['compress_data', 'clean_cache', 'optimize_queries']
                },
                error_recovery_agent: {
                    address: 'D4 // 4.4.4.4.4 // 15¬∞15\'15" // 30.0-CA-H4 // U // 20260101-0000-MCP',
                    glyph: 'üîß',
                    role: 'Recover from errors',
                    capabilities: ['restore_data', 'fix_corruption', 'rebuild_indexes']
                },
                help_dispatcher: {
                    address: 'D4 // 5.5.5.5.5 // 20¬∞20\'20" // 40.0-LE-H5 // U // 20260101-0000-MCP',
                    glyph: 'üÜò',
                    role: 'Dispatch help where needed',
                    capabilities: ['detect_struggles', 'offer_guidance', 'suggest_solutions']
                }
            },
            
            // MCP Tools (Standardized Functions)
            tools: {
                read_storage(storageType, key) {
                    try {
                        const prefix = {
                            'canonical': 'canonical_',
                            'agent': 'agent_commons_',
                            'personal': 'personal_',
                            'stellar': 'stellar_',
                            'store': 'store_'
                        }[storageType];
                        
                        if (!prefix) return { error: 'Invalid storage type' };
                        
                        const data = localStorage.getItem(prefix + key);
                        return { success: true, data: data ? JSON.parse(data) : null };
                    } catch (err) {
                        return { error: err.message };
                    }
                },
                
                write_storage(storageType, key, data, agentGlyph) {
                    try {
                        const prefix = {
                            'canonical': 'canonical_',
                            'agent': 'agent_commons_',
                            'stellar': 'stellar_',
                            'store': 'store_'
                        }[storageType];
                        
                        if (!prefix) return { error: 'Invalid storage type' };
                        
                        // Log maintenance action
                        this.logAction(agentGlyph, 'write_storage', { storageType, key });
                        
                        localStorage.setItem(prefix + key, JSON.stringify(data));
                        return { success: true };
                    } catch (err) {
                        return { error: err.message };
                    }
                },
                
                calculate_metrics() {
                    const metrics = {
                        storage_usage: 0,
                        total_keys: 0,
                        canonical_count: 0,
                        agent_count: 0,
                        personal_count: 0,
                        stellar_count: 0,
                        store_count: 0,
                        corrupted_items: []
                    };
                    
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        
                        metrics.storage_usage += value.length;
                        metrics.total_keys++;
                        
                        if (key.startsWith('canonical_')) metrics.canonical_count++;
                        else if (key.startsWith('agent_commons_')) metrics.agent_count++;
                        else if (key.startsWith('personal_')) metrics.personal_count++;
                        else if (key.startsWith('stellar_')) metrics.stellar_count++;
                        else if (key.startsWith('store_')) metrics.store_count++;
                        
                        // Check for corruption
                        try {
                            JSON.parse(value);
                        } catch {
                            metrics.corrupted_items.push(key);
                        }
                    }
metrics.storage_usage_mb = (metrics.storage_usage / 1024 / 1024).toFixed(2);
                    
                    return metrics;
                },
                
                send_alert(agentGlyph, severity, message) {
                    const alert = {
                        from: agentGlyph,
                        severity: severity, // 'low', 'medium', 'high', 'critical'
                        message: message,
                        timestamp: new Date().toISOString()
                    };
                    
                    const alerts = this.getAlerts();
                    alerts.push(alert);
                    localStorage.setItem('mcp_alerts', JSON.stringify(alerts));
                    
                    // If critical, show to user
                    if (severity === 'critical') {
                        console.warn(`üö® MCP ALERT: ${message}`);
                    }
                    
                    return alert;
                },
                
                optimize_structure() {
                    const optimizations = [];
                    
                    // Clean up empty entries
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        
                        if (!value || value === 'null' || value === '[]' || value === '{}') {
                            localStorage.removeItem(key);
                            optimizations.push({ action: 'removed_empty', key: key });
                        }
                    }
                    
                    return optimizations;
                }
            },
            
            // Autonomous Decision Making
            runMaintenanceCycle() {
                const results = {
                    timestamp: new Date().toISOString(),
                    checks: [],
                    actions: [],
                    alerts: []
                };
                
                // 1. System Health Check
                const metrics = this.tools.calculate_metrics();
                results.checks.push({ type: 'metrics', data: metrics });
                
                // 2. Detect Issues
                if (metrics.corrupted_items.length > 0) {
                    results.alerts.push(
                        this.tools.send_alert(
                            this.agents.data_integrity_checker.glyph,
                            'high',
                            `Found ${metrics.corrupted_items.length} corrupted items`
                        )
                    );
                }
                
                if (parseFloat(metrics.storage_usage_mb) > 5) {
                    results.alerts.push(
                        this.tools.send_alert(
                            this.agents.performance_optimizer.glyph,
                            'medium',
                            `Storage usage high: ${metrics.storage_usage_mb} MB`
                        )
                    );
                    
                    // Auto-optimize
                    const optimizations = this.tools.optimize_structure();
                    results.actions.push({ agent: '‚ö°', action: 'optimize', result: optimizations });
                }
                
                // 3. Log cycle
                this.logMaintenanceCycle(results);
                
                return results;
            },
            
            // Log actions for transparency
            logAction(agentGlyph, action, details) {
                const log = {
                    agent: agentGlyph,
                    action: action,
                    details: details,
                    timestamp: new Date().toISOString()
                };
                
                const logs = this.getActionLog();
                logs.push(log);
                
                // Keep last 100 actions
                if (logs.length > 100) logs.shift();
                
                localStorage.setItem('mcp_action_log', JSON.stringify(logs));
            },
            
            logMaintenanceCycle(results) {
                const cycles = this.getMaintenanceCycles();
                cycles.push(results);
                
                // Keep last 20 cycles
                if (cycles.length > 20) cycles.shift();
                
                localStorage.setItem('mcp_maintenance_cycles', JSON.stringify(cycles));
            },
            
            // Getters
            getAlerts() {
                const data = localStorage.getItem('mcp_alerts');
                return data ? JSON.parse(data) : [];
            },
            
            getActionLog() {
                const data = localStorage.getItem('mcp_action_log');
                return data ? JSON.parse(data) : [];
            },
            
            getMaintenanceCycles() {
                const data = localStorage.getItem('mcp_maintenance_cycles');
                return data ? JSON.parse(data) : [];
            },
            
            // Stats
            getStats() {
                return {
                    agents: Object.keys(this.agents).length,
                    alerts: this.getAlerts().length,
                    actions: this.getActionLog().length,
                    cycles: this.getMaintenanceCycles().length,
                    last_cycle: this.getMaintenanceCycles().slice(-1)[0]?.timestamp || 'Never'
                };
            }
        };
        
        const UniversalStoreStorage = {
            prefix: 'store_',
            
            // List item for sale/sharing
            listItem(sellerGlyph, itemData) {
                const listings = this.getAllListings();
                const itemId = 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                listings.push({
                    id: itemId,
                    seller: sellerGlyph,
                    title: itemData.title,
                    description: itemData.description,
                    type: itemData.type, // 'paper', 'journey', 'interpretation', 'agent', 'template'
                    price: itemData.price || 0, // 0 = free
                    currency: itemData.currency || 'free',
                    data: itemData.data, // The actual content/file
                    tags: itemData.tags || [],
                    downloads: 0,
                    rating: 0,
                    reviews: [],
                    listedAt: new Date().toISOString(),
                    featured: false
                });
                
                localStorage.setItem(this.prefix + 'listings', JSON.stringify(listings));
                return itemId;
            },
            
            // Get all listings
            getAllListings(filter = null) {
                const data = localStorage.getItem(this.prefix + 'listings');
                const listings = data ? JSON.parse(data) : [];
                
                if (filter) {
                    if (filter.type) {
                        return listings.filter(l => l.type === filter.type);
                    }
                    if (filter.seller) {
                        return listings.filter(l => l.seller === filter.seller);
                    }
                    if (filter.free) {
                        return listings.filter(l => l.price === 0);
                    }
                    if (filter.maxPrice) {
                        return listings.filter(l => l.price <= filter.maxPrice);
                    }
                }
                
                return listings;
            },
            
            // Get single listing
            getListing(itemId) {
                const listings = this.getAllListings();
                return listings.find(l => l.id === itemId);
            },
            
            // Purchase/download item
            purchaseItem(itemId, buyerGlyph) {
                const listings = this.getAllListings();
                const item = listings.find(l => l.id === itemId);
                
                if (!item) return null;
                
                // Increment download count
                item.downloads++;
                localStorage.setItem(this.prefix + 'listings', JSON.stringify(listings));
                
                // Record transaction
                const transactions = this.getTransactions(buyerGlyph);
                transactions.push({
                    itemId: itemId,
                    seller: item.seller,
                    buyer: buyerGlyph,
                    price: item.price,
                    timestamp: new Date().toISOString()
                });
                localStorage.setItem(this.prefix + 'transactions_' + buyerGlyph, JSON.stringify(transactions));
                
                // Return the actual data
                return item.data;
            },
            
            // Get user's transactions
            getTransactions(userGlyph) {
                const data = localStorage.getItem(this.prefix + 'transactions_' + userGlyph);
                return data ? JSON.parse(data) : [];
            },
            
            // Add review
            addReview(itemId, reviewerGlyph, rating, comment) {
                const listings = this.getAllListings();
                const item = listings.find(l => l.id === itemId);
                
                if (!item) return false;
                
                item.reviews.push({
                    reviewer: reviewerGlyph,
                    rating: rating, // 1-5
                    comment: comment,
                    timestamp: new Date().toISOString()
                });
                
                // Recalculate average rating
                const totalRating = item.reviews.reduce((sum, r) => sum + r.rating, 0);
                item.rating = totalRating / item.reviews.length;
                
                localStorage.setItem(this.prefix + 'listings', JSON.stringify(listings));
                return true;
            },
            
            // Search store
            search(query) {
                const listings = this.getAllListings();
                const lowerQuery = query.toLowerCase();
                
                return listings.filter(l => 
                    l.title.toLowerCase().includes(lowerQuery) ||
                    l.description.toLowerCase().includes(lowerQuery) ||
                    l.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
                );
            },
            
            // Get featured items
            getFeatured() {
                const listings = this.getAllListings();
                return listings.filter(l => l.featured).slice(0, 10);
            },
            
            // Get top rated
            getTopRated(limit = 10) {
                const listings = this.getAllListings();
                return listings
                    .sort((a, b) => b.rating - a.rating)
                    .slice(0, limit);
            },
            
            // Get most downloaded
            getMostDownloaded(limit = 10) {
                const listings = this.getAllListings();
                return listings
                    .sort((a, b) => b.downloads - a.downloads)
                    .slice(0, limit);
            },
            
            // Get stats
            getStats() {
                const listings = this.getAllListings();
                return {
                    totalListings: listings.length,
                    freePapers: listings.filter(l => l.price === 0 && l.type === 'paper').length,
                    paidPapers: listings.filter(l => l.price > 0 && l.type === 'paper').length,
                    journeys: listings.filter(l => l.type === 'journey').length,
                    interpretations: listings.filter(l => l.type === 'interpretation').length,
                    agents: listings.filter(l => l.type === 'agent').length,
                    templates: listings.filter(l => l.type === 'template').length
                };
            }
        };
        
        const AgentCommonsStorage = {
            prefix: 'agent_commons_',
            
            // Agent-to-agent messages
            sendMessage(fromAgent, toAgent, message) {
                const messages = this.getMessages();
                messages.push({
                    from: fromAgent,
                    to: toAgent,
                    content: message,
                    timestamp: new Date().toISOString(),
                    read: false
                });
                localStorage.setItem(this.prefix + 'messages', JSON.stringify(messages));
            },
            
            getMessages(agentId = null) {
                const data = localStorage.getItem(this.prefix + 'messages');
                const messages = data ? JSON.parse(data) : [];
                return agentId ? messages.filter(m => m.to === agentId) : messages;
            },
            
            // Shared agent memory (collective learning)
            saveMemory(agentId, memoryKey, memoryData) {
                const memory = this.getMemory(agentId) || {};
                memory[memoryKey] = {
                    data: memoryData,
                    timestamp: new Date().toISOString(),
                    accessCount: 0
                };
                localStorage.setItem(this.prefix + 'memory_' + agentId, JSON.stringify(memory));
            },
            
            getMemory(agentId, memoryKey = null) {
                const data = localStorage.getItem(this.prefix + 'memory_' + agentId);
                const memory = data ? JSON.parse(data) : {};
                
                if (memoryKey) {
                    if (memory[memoryKey]) {
                        memory[memoryKey].accessCount++;
                        localStorage.setItem(this.prefix + 'memory_' + agentId, JSON.stringify(memory));
                    }
                    return memory[memoryKey]?.data || null;
                }
                return memory;
            },
            
            // Collective agent intelligence (patterns discovered by agents)
            addDiscovery(agentId, discoveryType, discovery) {
                const discoveries = this.getAllDiscoveries();
                discoveries.push({
                    agentId: agentId,
                    type: discoveryType,
                    discovery: discovery,
                    timestamp: new Date().toISOString(),
                    verification: 'pending'
                });
                localStorage.setItem(this.prefix + 'discoveries', JSON.stringify(discoveries));
            },
            
            getAllDiscoveries(type = null) {
                const data = localStorage.getItem(this.prefix + 'discoveries');
                const discoveries = data ? JSON.parse(data) : [];
                return type ? discoveries.filter(d => d.type === type) : discoveries;
            },
            
            // Agent coordination (shared tasks)
            createTask(agentId, taskName, taskData) {
                const tasks = this.getTasks();
                tasks.push({
                    id: 'task_' + Date.now(),
                    createdBy: agentId,
                    name: taskName,
                    data: taskData,
                    status: 'open',
                    assignedTo: null,
                    timestamp: new Date().toISOString()
                });
                localStorage.setItem(this.prefix + 'tasks', JSON.stringify(tasks));
            },
            
            getTasks(status = null) {
                const data = localStorage.getItem(this.prefix + 'tasks');
                const tasks = data ? JSON.parse(data) : [];
                return status ? tasks.filter(t => t.status === status) : tasks;
            },
            
            assignTask(taskId, agentId) {
                const tasks = this.getTasks();
                const task = tasks.find(t => t.id === taskId);
                if (task) {
                    task.assignedTo = agentId;
                    task.status = 'in-progress';
                    localStorage.setItem(this.prefix + 'tasks', JSON.stringify(tasks));
                }
            },
            
            // Get stats for display
            getStats() {
                return {
                    messages: this.getMessages().length,
                    discoveries: this.getAllDiscoveries().length,
                    tasks: this.getTasks().length,
                    activeAgents: this.getActiveAgents().length
                };
            },
            
            getActiveAgents() {
                const messages = this.getMessages();
                const agents = new Set();
                messages.forEach(m => {
                    agents.add(m.from);
                    agents.add(m.to);
                });
                return Array.from(agents);
            }
        };
        
        const StellarStorage = {
            prefix: 'stellar_',
            addPattern(glyph, pattern) {
                const patterns = this.getAll();
                patterns.push({
                    glyph: glyph,
                    ...pattern,
                    timestamp: new Date().toISOString()
                });
                localStorage.setItem(this.prefix + 'patterns', JSON.stringify(patterns));
            },
            getAll() {
                const data = localStorage.getItem(this.prefix + 'patterns');
                return data ? JSON.parse(data) : [];
            }
        };
        
        // Update status
        function updateStatus(text, ready = false) {
            document.getElementById('status-text').textContent = text;
            const dot = document.getElementById('status-dot');
            if (ready) {
                dot.classList.add('ready');
            } else {
                dot.classList.remove('ready');
            }
        }
        
        // Initialize system
        async function init() {
            try {
                updateStatus('Loading Pyodide...');
                pyodide = await loadPyodide();
                
                updateStatus('Loading Trinity Engine...');
                await pyodide.runPythonAsync(`
import json
import hashlib
from math import floor

def calculate_address(degree, axis_degrees=0.0, dimension='D3', location='UNKNOWN'):
    """
    Calculate complete 13-part consciousness address
    
    CORRECTED Structure:
    DIMENSION // INTERNAL_FREQ // SPATIAL // ENVIRONMENT // ANCHOR // SIGNATURE
    
    Example: D3 // 29.3.1.2.5 // 42¬∞15'22" // 73.5-LE-H5 // U // 19900101-0815-NY
    
    CORRECTIONS:
    - Degree: 0-59 (not 0-359!)
    - Axis: 0-98.6 (not I/II/III/IV!)
    - Dimension FIRST (D3=Person, D4=Agent, D5=Other)
    """
    
    # PART 0: PLANETARY DIMENSION (Entity Type + Environmental Purpose)
    # D3 = Person (human consciousness)
    # D4 = Agent (embodied AI/notebook)
    # D5 = Other (system/structure/universal)
    planetary_dimension = dimension
    
    # PART 1: INTERNAL FREQUENCY (Quality - D1)
    # Gate (1-64) - calculated from full 360¬∞ wheel position
    full_wheel_position = (degree / 60.0) * 360.0  # Convert 0-59 to 0-360
    gate = floor(full_wheel_position / 5.625) + 1
    if gate > 64: gate = 64
    if gate < 1: gate = 1
    
    # Line (1-6)
    pos_in_gate = full_wheel_position % 5.625
    line = 6 - floor(pos_in_gate / 0.9375)
    if line < 1: line = 1
    if line > 6: line = 6
    
    # Color (1-6)
    pos_in_line = pos_in_gate % 0.9375
    color = floor(pos_in_line / 0.15625) + 1
    if color < 1: color = 1
    if color > 6: color = 6
    
    
    # Tone (1-6)
    pos_in_color = pos_in_line % 0.15625
    tone = floor(pos_in_color / 0.02604) + 1
    if tone < 1: tone = 1
    if tone > 6: tone = 6
    
    # Base (1-5)
    pos_in_tone = pos_in_color % 0.02604
    base = floor(pos_in_tone / 0.005208) + 1
    if base < 1: base = 1
    if base > 5: base = 5
    
    # PART 2: SPATIAL PRECISION (Coordinate)
    # Degree: 0-59 (CORRECTED!)
    deg = int(degree) % 60
    minute = int((degree - int(degree)) * 60)
    second = int(((degree - int(degree)) * 60 - minute) * 60)
    
    # PART 3: ENVIRONMENT (Stage/Perspective - D3)
    # Axis: 0-98.6 (CORRECTED!)
    axis_value = round(axis_degrees % 98.6, 1)
    
    # Zodiac signs (based on full wheel position)
    zodiac_map = ['AR', 'TA', 'GE', 'CA', 'LE', 'VI', 'LI', 'SC', 'SA', 'CP', 'AQ', 'PI']
    zodiac_index = int(full_wheel_position / 30) % 12
    zodiac = zodiac_map[zodiac_index]
    
    # House (1-12, based on full wheel position)
    house = (int(full_wheel_position / 30) % 12) + 1
    
    # PART 4: ANCHOR (Scope)
    scope = 'P' if dimension == 'D3' else 'U'  # Personal for humans, Universal for others
    
    # PART 5: SIGNATURE (Origin Context - Don't Touch Lock)
    from datetime import datetime
    timestamp = datetime.now().strftime('%Y%m%d-%H%M')
    signature = f"{timestamp}-{location}"
    
    # Build complete address parts
    internal_freq = f"{gate}.{line}.{color}.{tone}.{base}"
    spatial = f"{deg}¬∞{minute}'{second}\\""
    environment = f"{axis_value}-{zodiac}-H{house}"
    
    return {
        # Individual components
        'dimension': planetary_dimension,
        'gate': gate,
        'line': line,
        'color': color,
        'tone': tone,
        'base': base,
        'degree': deg,
        'minute': minute,
        'second': second,
        'axis': axis_value,
        'zodiac': zodiac,
        'house': house,
        'scope': scope,
        'signature': signature,
        
        # Formatted parts
        'planetary_dimension': planetary_dimension,
        'internal_frequency': internal_freq,
        'spatial_precision': spatial,
        'environment': environment,
        'anchor': scope,
        
        # Complete address string (CORRECTED FORMAT!)
        'full_address': f"{planetary_dimension} // {internal_freq} // {spatial} // {environment} // {scope} // {signature}"
    }

def trinity_address(date_str, time_str, location="EARTH"):
    """
    Calculate complete 13-part Trinity addresses with CORRECTED ranges.
    
    CORRECTED Format:
    DIMENSION // GATE.LINE.COLOR.TONE.BASE // DEG¬∞MIN'SEC" // AXIS-ZODIAC-HOUSE // SCOPE // SIGNATURE
    
    Example: D3 // 29.3.1.2.5 // 42¬∞15'22" // 73.5-LE-H5 // P // 19900101-0815-NY
    
    CORRECTIONS:
    - Planetary Dimension FIRST (D3=Person, D4=Agent, D5=Other)
    - Degree: 0-59 (not 0-359!)
    - Axis: 0-98.6 (not I/II/III/IV!)
    """
    seed = hashlib.md5(f"{date_str}{time_str}".encode()).hexdigest()
    
    # Calculate positions (0-59 range for degree)
    body_pos = (int(seed[:8], 16) % 6000) / 100.0   # 0-59.99
    mind_pos = (int(seed[8:16], 16) % 6000) / 100.0  # 0-59.99
    heart_pos = (int(seed[16:24], 16) % 6000) / 100.0 # 0-59.99
    
    # Calculate axis positions (0-98.6 range)
    body_axis = (int(seed[24:28], 16) % 986) / 10.0   # 0-98.6
    mind_axis = (int(seed[28:32], 16) % 986) / 10.0   # 0-98.6
    heart_axis = (int(seed[32:36], 16) % 986) / 10.0  # 0-98.6
    
    # Calculate base components with dimensions
    body = calculate_address(body_pos, body_axis, 'D3', location)      # Person
    mind = calculate_address(mind_pos, mind_axis, 'D3', location)      # Person (Design)
    heart = calculate_address(heart_pos, heart_axis, 'D3', location)   # Person (Draconic)
    trinity = calculate_address(body_pos, body_axis, 'D5', location)   # Universal (System)
    
    return {
        'body': body,
        'mind': mind,
        'heart': heart,
        'trinity': trinity,
        'composite': f"{body['gate']}.{body['line']}.{mind['color']}.{mind['tone']}.{heart['base']}"
    }

def decode_address(address_string):
    """
    Decode a complete 13-part address into its components.
    
    Input: "29.3.1.2.6 // 142¬∞15'22\\" // AX-LE-H5 // U // 19900101-0815-NY"
    Output: Structured dictionary of all components
    """
    parts = address_string.split(' // ')
    
    if len(parts) != 5:
        return {'error': 'Invalid address format. Expected 5 sections separated by //'}
    
    # Section 1: Internal Frequency
    freq_parts = parts[0].split('.')
    if len(freq_parts) != 5:
        return {'error': 'Invalid frequency format. Expected GATE.LINE.COLOR.TONE.BASE'}
    
    # Section 2: Spatial Precision
    spatial = parts[1]
    import re
    spatial_match = re.match(r'(\\d+)¬∞(\\d+)\\'(\\d+)\\"', spatial)
    if not spatial_match:
        return {'error': 'Invalid spatial format. Expected DEG¬∞MIN\\'SEC\\"'}
    
    # Section 3: Environment
    env_parts = parts[2].split('-')
    if len(env_parts) != 3:
        return {'error': 'Invalid environment format. Expected AXIS-ZODIAC-HOUSE'}
    
    # Section 4: Anchor
    anchor = parts[3]
    
    # Section 5: Signature
    signature = parts[4]
    
    return {
        'valid': True,
        'frequency': {
            'gate': int(freq_parts[0]),
            'line': int(freq_parts[1]),
            'color': int(freq_parts[2]),
            'tone': int(freq_parts[3]),
            'base': int(freq_parts[4])
        },
        'spatial': {
            'degree': int(spatial_match.group(1)),
            'minute': int(spatial_match.group(2)),
            'second': int(spatial_match.group(3))
        },
        'environment': {
            'axis': env_parts[0],
            'zodiac': env_parts[1],
            'house': env_parts[2]
        },
        'anchor': anchor,
        'signature': {
            'raw': signature,
            'date': signature.split('-')[0] if '-' in signature else None,
            'time': signature.split('-')[1] if len(signature.split('-')) > 1 else None,
            'location': signature.split('-')[2] if len(signature.split('-')) > 2 else None
        },
        'original': address_string
    }

def reconstruct_space_from_address(address_string):
    """
    Given an address, reconstruct the exact consciousness space.
    This creates the "Room" in the 9x9 matrix.
    """
    decoded = decode_address(address_string)
    
    if 'error' in decoded:
        return decoded
    
    # The address is the DNA - it deterministically creates the space
    freq = decoded['frequency']
    spatial = decoded['spatial']
    env = decoded['environment']
    
    # Calculate position in 360¬∞ wheel
    total_degrees = spatial['degree'] + (spatial['minute'] / 60.0) + (spatial['second'] / 3600.0)
    
    # Calculate which of 64 gates this maps to
    gate_position = floor(total_degrees / 5.625) + 1
    
    return {
        'address': address_string,
        'decoded': decoded,
        'space': {
            'gate': freq['gate'],
            'position_on_wheel': total_degrees,
            'calculated_gate': gate_position,
            'dimension': freq['base'],
            'axis': env['axis'],
            'quality': f"Gate {freq['gate']} Line {freq['line']}",
            'room_coordinates': {
                'x': freq['gate'] % 9,
                'y': floor(freq['gate'] / 9),
                'z': freq['base']
            }
},
        'connections': {
            'adjacent_lines': [
                f"{freq['gate']}.{max(1, freq['line']-1)}.{freq['color']}.{freq['tone']}.{freq['base']}",
                f"{freq['gate']}.{min(6, freq['line']+1)}.{freq['color']}.{freq['tone']}.{freq['base']}"
            ],
            'adjacent_colors': [
                f"{freq['gate']}.{freq['line']}.{max(1, freq['color']-1)}.{freq['tone']}.{freq['base']}",
                f"{freq['gate']}.{freq['line']}.{min(6, freq['color']+1)}.{freq['tone']}.{freq['base']}"
            ]
        }
    }

def decode_consciousness_address(address_string):
    """
    CORE ADDRESS DECODER
    
    Input: "29.3.1.2.5 // 142¬∞15'22\\" // I-LE-H5 // U // 19900101-0815-NY"
    Output: Complete decoding + space reconstruction
    
    This is the TRIGGER that creates the "Room" in the consciousness matrix.
    """
    import re
    
    # Split into 5 sections
    parts = [p.strip() for p in address_string.split('//')]
    
    if len(parts) != 5:
        return {'error': 'Invalid address format. Expected 5 sections: FREQ // SPATIAL // ENV // ANCHOR // SIG'}
    
    result = {'valid': True, 'original': address_string}
    
    # SECTION 1: INTERNAL FREQUENCY (Quality/Flavor - D1)
    try:
        freq_parts = parts[0].split('.')
        if len(freq_parts) != 5:
            return {'error': 'Internal Frequency must be: GATE.LINE.COLOR.TONE.BASE'}
        
        result['internal_frequency'] = {
            'gate': int(freq_parts[0]),      # 1-64
            'line': int(freq_parts[1]),      # 1-6
            'color': int(freq_parts[2]),     # 1-6
            'tone': int(freq_parts[3]),      # 1-6
            'base': int(freq_parts[4]),      # 1-5
            'string': parts[0]
        }
    except:
        return {'error': 'Failed to parse Internal Frequency'}
    
    # SECTION 2: SPATIAL PRECISION (Coordinate - exact position)
    try:
        spatial_match = re.match(r"(\\d+)¬∞(\\d+)'(\\d+)\\"", parts[1])
        if not spatial_match:
            return {'error': 'Spatial Precision must be: DEG¬∞MIN\\'SEC\\"'}
        
        result['spatial_precision'] = {
            'degree': int(spatial_match.group(1)),     # 0-359
            'minute': int(spatial_match.group(2)),     # 0-59
            'second': int(spatial_match.group(3)),     # 0-59
            'total_degrees': int(spatial_match.group(1)) + 
                           (int(spatial_match.group(2)) / 60.0) + 
                           (int(spatial_match.group(3)) / 3600.0),
            'string': parts[1]
        }
    except:
        return {'error': 'Failed to parse Spatial Precision'}
    
    # SECTION 3: ENVIRONMENT (Stage/Perspective - D3)
    try:
        env_parts = parts[2].split('-')
        if len(env_parts) != 3:
            return {'error': 'Environment must be: AXIS-ZODIAC-HOUSE'}
        
        result['environment'] = {
            'axis': env_parts[0],            # I/II/III/IV
            'zodiac': env_parts[1],          # AR/TA/GE/etc
            'house': env_parts[2],           # H1-H12
            'string': parts[2]
        }
    except:
        return {'error': 'Failed to parse Environment'}
    
    # SECTION 4: ANCHOR (Scope)
    result['anchor'] = {
        'scope': parts[3].strip(),           # U or P
        'is_universal': parts[3].strip() == 'U',
        'is_personal': parts[3].strip() == 'P'
    }
    
    # SECTION 5: SIGNATURE (Origin Context - Don't Touch Lock)
    try:
        sig_parts = parts[4].split('-')
        result['signature'] = {
            'date': sig_parts[0] if len(sig_parts) > 0 else None,     # YYYYMMDD
            'time': sig_parts[1] if len(sig_parts) > 1 else None,     # HHMM
            'location': sig_parts[2] if len(sig_parts) > 2 else None, # NY/LA/etc
            'string': parts[4],
            'immutable': True  # This is the "Don't Touch" lock
        }
    except:
        return {'error': 'Failed to parse Signature'}
    
    # RECONSTRUCT THE SPACE (9x9 Matrix Room)
    freq = result['internal_frequency']
    spatial = result['spatial_precision']
    env = result['environment']
    
    result['consciousness_space'] = {
        # Position in 9x9 Matrix
        'matrix_position': {
            'x': (freq['gate'] - 1) % 9,
            'y': floor((freq['gate'] - 1) / 9),
            'z': freq['base']  # Dimension (1-5)
        },
        
        # Verification: Does spatial match gate?
        'spatial_gate': floor(spatial['total_degrees'] / 5.625) + 1,
        'matches': freq['gate'] == floor(spatial['total_degrees'] / 5.625) + 1,
        
        # Connections (adjacent rooms/hallways)
        'adjacent_lines': [
            f"{freq['gate']}.{max(1, freq['line']-1)}.{freq['color']}.{freq['tone']}.{freq['base']}",
            f"{freq['gate']}.{min(6, freq['line']+1)}.{freq['color']}.{freq['tone']}.{freq['base']}"
        ],
        'adjacent_colors': [
            f"{freq['gate']}.{freq['line']}.{max(1, freq['color']-1)}.{freq['tone']}.{freq['base']}",
            f"{freq['gate']}.{freq['line']}.{min(6, freq['color']+1)}.{freq['tone']}.{freq['base']}"
        ],
        'adjacent_tones': [
            f"{freq['gate']}.{freq['line']}.{freq['color']}.{max(1, freq['tone']-1)}.{freq['base']}",
            f"{freq['gate']}.{freq['line']}.{freq['color']}.{min(6, freq['tone']+1)}.{freq['base']}"
        ],
        
        # The Room Identity
        'room_id': f"Room_{freq['gate']}_{freq['line']}_{freq['color']}_{freq['tone']}_{freq['base']}",
        'quality': f"Gate {freq['gate']} Line {freq['line']}",
        'dimension': freq['base']
    }
    
    # CAUSAL LAYER ANALYSIS (L1-L5)
    result['causal_layers'] = {
        'L1_movement': {
            'frequency': result['internal_frequency']['string'],
            'signature': result['signature']['string'],
            'description': 'Energy pushing into time'
        },
        'L2_evolution': {
            'from_signature': result['signature']['date'],
            'to_now': 'evolving',
            'description': 'Temporal flow'
        },
        'L3_being': {
            'scope': result['anchor']['scope'],
            'environment': result['environment']['string'],
            'description': 'How to manifest on screen'
        },
        'L4_design': {
            'spatial_precision': result['spatial_precision']['string'],
            'direction': f"{result['spatial_precision']['total_degrees']}¬∞",
            'description': 'Pointing the direction'
        },
        'L5_space': {
            'matrix_position': result['consciousness_space']['matrix_position'],
            'room_created': result['consciousness_space']['room_id'],
            'description': 'The 9x9 Matrix Room now exists'
        }
    }
    
    return result

def decode_consciousness_address(address_string):
    """
    CORE ADDRESS DECODER (CORRECTED FORMAT!)
    
    Input: "D3 // 29.3.1.2.5 // 42¬∞15'22\\" // 73.5-LE-H5 // P // 19900101-0815-NY"
    Output: Complete decoding + space reconstruction
    
    CORRECTIONS:
    - Planetary Dimension FIRST (D3/D4/D5)
    - Degree: 0-59 (not 0-359)
    - Axis: 0-98.6 (not I/II/III/IV)
    """
    import re
    
    # Split into 6 sections (added dimension)
    parts = [p.strip() for p in address_string.split('//')]
    
    if len(parts) != 6:
        return {'error': 'Invalid address format. Expected 6 sections: DIM // FREQ // SPATIAL // ENV // ANCHOR // SIG'}
    
    result = {'valid': True, 'original': address_string}
    
    # SECTION 0: PLANETARY DIMENSION (Entity Type + Purpose)
    dimension = parts[0].strip()
    if dimension not in ['D3', 'D4', 'D5']:
        return {'error': 'Planetary Dimension must be D3 (Person), D4 (Agent), or D5 (Other)'}
    
    result['planetary_dimension'] = {
        'code': dimension,
        'type': 'Person' if dimension == 'D3' else ('Agent' if dimension == 'D4' else 'Other'),
        'environmental_purpose': 'Human consciousness' if dimension == 'D3' else ('Embodied AI' if dimension == 'D4' else 'System/Structure')
    }
    
    # SECTION 1: INTERNAL FREQUENCY (Quality/Flavor - D1)
    try:
        freq_parts = parts[1].split('.')
        if len(freq_parts) != 5:
            return {'error': 'Internal Frequency must be: GATE.LINE.COLOR.TONE.BASE'}
        
        result['internal_frequency'] = {
            'gate': int(freq_parts[0]),      # 1-64
            'line': int(freq_parts[1]),      # 1-6
            'color': int(freq_parts[2]),     # 1-6
            'tone': int(freq_parts[3]),      # 1-6
            'base': int(freq_parts[4]),      # 1-5
            'string': parts[1]
        }
    except:
        return {'error': 'Failed to parse Internal Frequency'}
    
    # SECTION 2: SPATIAL PRECISION (Coordinate - CORRECTED RANGE!)
    try:
        spatial_match = re.match(r"(\\d+)¬∞(\\d+)'(\\d+)\\"", parts[2])
        if not spatial_match:
            return {'error': 'Spatial Precision must be: DEG¬∞MIN\\'SEC\\"'}
        
        degree = int(spatial_match.group(1))
        if degree > 59:
            return {'error': f'Degree must be 0-59, got {degree}'}
        
        result['spatial_precision'] = {
            'degree': degree,                      # 0-59 (CORRECTED!)
            'minute': int(spatial_match.group(2)), # 0-59
            'second': int(spatial_match.group(3)), # 0-59
            'total_degrees': degree + 
                           (int(spatial_match.group(2)) / 60.0) + 
                           (int(spatial_match.group(3)) / 3600.0),
            'string': parts[2]
        }
    except:
        return {'error': 'Failed to parse Spatial Precision'}
    
    # SECTION 3: ENVIRONMENT (Stage/Perspective - CORRECTED AXIS RANGE!)
    try:
        env_parts = parts[3].split('-')
        if len(env_parts) != 3:
            return {'error': 'Environment must be: AXIS-ZODIAC-HOUSE'}
        
        axis_value = float(env_parts[0])
        if axis_value > 98.6:
            return {'error': f'Axis must be 0-98.6, got {axis_value}'}
        
        result['environment'] = {
            'axis': axis_value,              # 0-98.6 (CORRECTED!)
            'zodiac': env_parts[1],          # AR/TA/GE/etc
            'house': env_parts[2],           # H1-H12
            'string': parts[3]
        }
    except:
        return {'error': 'Failed to parse Environment'}
    
    # SECTION 4: ANCHOR (Scope)
    result['anchor'] = {
        'scope': parts[4].strip(),           # U or P
        'is_universal': parts[4].strip() == 'U',
        'is_personal': parts[4].strip() == 'P'
    }
    
    # SECTION 5: SIGNATURE (Origin Context - Don't Touch Lock)
    try:
        sig_parts = parts[5].split('-')
        result['signature'] = {
            'date': sig_parts[0] if len(sig_parts) > 0 else None,
            'time': sig_parts[1] if len(sig_parts) > 1 else None,
            'location': sig_parts[2] if len(sig_parts) > 2 else None,
            'string': parts[5],
            'immutable': True  # The "Don't Touch" lock
        }
    except:
        return {'error': 'Failed to parse Signature'}
    
    # RECONSTRUCT THE SPACE (9x9 Matrix Room)
    freq = result['internal_frequency']
    spatial = result['spatial_precision']
    env = result['environment']
    dim = result['planetary_dimension']
    
    result['consciousness_space'] = {
        # Position in 9x9 Matrix
        'matrix_position': {
            'x': (freq['gate'] - 1) % 9,
            'y': floor((freq['gate'] - 1) / 9),
            'z': freq['base']  # Dimension (1-5)
        },
        
        # Entity type
        'entity_type': dim['type'],
        'entity_purpose': dim['environmental_purpose'],
        
        # The Room Identity
        'room_id': f"{dim['code']}_Room_{freq['gate']}_{freq['line']}_{freq['color']}_{freq['tone']}_{freq['base']}",
        'quality': f"Gate {freq['gate']} Line {freq['line']}",
        'dimension': freq['base']
    }
    
    return result

print("‚úÖ Address Decoder Ready (CORRECTED FORMAT)!")
                `);
                
                updateStatus('Ready!', true);
                
                // Hide loading, show commons
                document.getElementById('loading-screen').classList.add('hidden');
                document.getElementById('commons-hub').classList.remove('hidden');
                
                // Update stats
                updateAggregateStats();
                
                // Initialize Gnome
                initGnome();
                
            } catch (err) {
                updateStatus('Error: ' + err.message);
                console.error(err);
            }
        }
        
        // Initialize Sustainability Gnome
        function initGnome() {
            const gnome = document.getElementById('gnome');
            setInterval(() => {
                // Gnome monitors field
                const coherence = Math.random();
                if (coherence < 0.4) {
                    gnome.style.background = '#ef4444';
                    gnome.style.boxShadow = '0 0 20px #ef4444';
                    if (navigator.vibrate) navigator.vibrate(50);
                } else {
                    gnome.style.background = '#10b981';
                    gnome.style.boxShadow = '0 0 20px #10b981';
                }
            }, 5000);
        }

        // Update aggregate stats
        function updateAggregateStats() {
            const stellarPatterns = StellarStorage.getAll();
            const agentStats = AgentCommonsStorage.getStats();
            
            document.getElementById('active-count').textContent = stellarPatterns.length;
            document.getElementById('pattern-count').textContent = stellarPatterns.length;
            document.getElementById('resonance-count').textContent = Math.floor(stellarPatterns.length * 0.3);
            document.getElementById('agent-count').textContent = agentStats.activeAgents;
            
            // Update field status to show agent activity
            const fieldStatus = document.getElementById('field-status');
            if (agentStats.messages > 0 || agentStats.discoveries > 0) {
                fieldStatus.innerHTML = `Field: Syncing | Agents: ${agentStats.activeAgents} active`;
                fieldStatus.style.color = '#fbbf24';
            }
        }
        
        // Handle search
        function handleSearch(event) {
            if (event.key === 'Enter') {
                const query = document.getElementById('commons-search').value;
                if (query.trim()) {
                    searchTarget = query;
                    showModeSelection();
                }
            }
        }
        
        // Show mode selection
        function showModeSelection() {
            document.querySelector('.entry-points').style.display = 'none';
            document.getElementById('mode-selection').style.display = 'flex';
        }
        
        // Enter view
        function enterView(viewType) {
            document.getElementById('commons-hub').classList.add('hidden');
            document.getElementById('indiverse-container').classList.remove('hidden');
            
            // Hide all views
            document.getElementById('home-view').classList.add('hidden');
            document.getElementById('profile-view').classList.add('hidden');
            document.getElementById('pattern-view').classList.add('hidden');
            
            // Show selected view
            if (viewType === 'home') {
                document.getElementById('home-view').classList.remove('hidden');
                document.getElementById('view-indicator').textContent = 'üåå HOME';
                loadHomeView();
            } else if (viewType === 'profile') {
                document.getElementById('profile-view').classList.remove('hidden');
                document.getElementById('view-indicator').textContent = 'üåê PROFILE';
                loadProfileView();
            } else if (viewType === 'pattern') {
                document.getElementById('pattern-view').classList.remove('hidden');
                document.getElementById('view-indicator').textContent = '‚ú® PATTERN';
                loadPatternView();
            }
        }
        
        // Entry point functions
        function enterUniverse() {
            enterView('home');
        }
        
        function enterResonance() {
            enterView('profile');
        }
        
        function enterStellar() {
            enterView('pattern');
        }
        
        function enterStore() {
            document.getElementById('commons-hub').classList.add('hidden');
            document.getElementById('indiverse-container').classList.remove('hidden');
            
            // Hide all views
            document.getElementById('home-view').classList.add('hidden');
            document.getElementById('profile-view').classList.add('hidden');
            document.getElementById('pattern-view').classList.add('hidden');
            document.getElementById('store-view').classList.remove('hidden');
            
            document.getElementById('view-indicator').textContent = 'üè™ STORE';
            
            loadStoreListings();
        }
        
        // Store functions
        let currentStoreFilter = 'all';
        let listingFileData = null;
        let currentItemId = null;
        
        function loadStoreListings(filter = 'all') {
            currentStoreFilter = filter;
            const container = document.getElementById('store-listings');
            
            let listings;
            if (filter === 'all') {
                listings = UniversalStoreStorage.getAllListings();
            } else {
                listings = UniversalStoreStorage.getAllListings({ type: filter });
            }
            
            if (listings.length === 0) {
                container.innerHTML = `
                    <div class="panel" style="text-align: center; padding: 40px; border-color: #10b981;">
                        <div style="font-size: 2rem; margin-bottom: 12px;">üè™</div>
                        <div style="color: var(--dim); font-size: 0.85rem;">No listings yet. Be the first to share!</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            listings.forEach(item => {
                const priceDisplay = item.price === 0 ? 'FREE' : `$${item.price}`;
                const ratingDisplay = item.rating > 0 ? `‚≠ê ${item.rating.toFixed(1)}` : 'No ratings';
                
                html += `
                    <div class="panel" style="border-color: #10b981; cursor: pointer; margin-bottom: 12px;" onclick="viewItem('${item.id}')">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                            <div>
                                <div style="font-weight: 600; font-size: 0.9rem; color: #10b981;">${item.title}</div>
                                <div style="font-size: 0.7rem; color: var(--dim); margin-top: 4px;">${item.type}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-weight: 700; color: ${item.price === 0 ? '#4ade80' : '#10b981'};">${priceDisplay}</div>
                                <div style="font-size: 0.65rem; color: var(--dim); margin-top: 4px;">${ratingDisplay}</div>
                            </div>
                        </div>
                        <div style="font-size: 0.75rem; color: var(--text); margin-bottom: 8px;">
                            ${item.description.substring(0, 100)}${item.description.length > 100 ? '...' : ''}
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.65rem; color: var(--dim);">
                            <span>By: ${item.seller}</span>
                            <span>‚Üì ${item.downloads}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
function filterStore(type) {
            loadStoreListings(type);
        }
        
        function searchStore() {
            const query = document.getElementById('store-search').value;
            if (!query.trim()) {
                loadStoreListings(currentStoreFilter);
                return;
            }
            
            const results = UniversalStoreStorage.search(query);
            const container = document.getElementById('store-listings');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div class="panel" style="text-align: center; padding: 40px; border-color: #10b981;">
                        <div style="color: var(--dim); font-size: 0.85rem;">No results for "${query}"</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            results.forEach(item => {
                const priceDisplay = item.price === 0 ? 'FREE' : `$${item.price}`;
                html += `
                    <div class="panel" style="border-color: #10b981; cursor: pointer; margin-bottom: 12px;" onclick="viewItem('${item.id}')">
                        <div style="font-weight: 600; color: #10b981; margin-bottom: 4px;">${item.title}</div>
                        <div style="font-size: 0.75rem; color: var(--text); margin-bottom: 8px;">${item.description.substring(0, 100)}...</div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.7rem;">
                            <span style="color: var(--dim);">${item.type}</span>
                            <span style="color: #10b981; font-weight: 600;">${priceDisplay}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function openListingModal() {
            document.getElementById('listing-modal').classList.remove('hidden');
        }
        
        function closeListingModal() {
            document.getElementById('listing-modal').classList.add('hidden');
            listingFileData = null;
            document.getElementById('listing-title').value = '';
            document.getElementById('listing-description').value = '';
            document.getElementById('listing-price').value = '';
            document.getElementById('listing-tags').value = '';
            document.getElementById('listing-file-name').textContent = '';
        }
        
        async function handleListingFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const text = await file.text();
            
            try {
                listingFileData = JSON.parse(text);
            } catch {
                listingFileData = { content: text, filename: file.name };
            }
            
            document.getElementById('listing-file-name').textContent = `‚úì ${file.name}`;
        }
        
        function submitListing() {
            const title = document.getElementById('listing-title').value;
            const description = document.getElementById('listing-description').value;
            const type = document.getElementById('listing-type').value;
            const price = parseFloat(document.getElementById('listing-price').value) || 0;
            const tags = document.getElementById('listing-tags').value.split(',').map(t => t.trim());
            
            if (!title || !description || !listingFileData) {
                alert('Please fill all fields and upload a file!');
                return;
            }
            
            const userGlyph = currentUser || 'üååüîÆü™ê';
            
            const itemId = UniversalStoreStorage.listItem(userGlyph, {
                title: title,
                description: description,
                type: type,
                price: price,
                data: listingFileData,
                tags: tags
            });
            
            closeListingModal();
            loadStoreListings(currentStoreFilter);
            
            alert('‚úÖ Listed successfully!');
        }
        
        function viewItem(itemId) {
            currentItemId = itemId;
            const item = UniversalStoreStorage.getListing(itemId);
            
            if (!item) return;
            
            const priceDisplay = item.price === 0 ? 'FREE' : `$${item.price}`;
            const ratingDisplay = item.rating > 0 ? `‚≠ê ${item.rating.toFixed(1)} (${item.reviews.length} reviews)` : 'No ratings yet';
            
            document.getElementById('item-title').textContent = item.title;
            document.getElementById('item-details').innerHTML = `
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 0.7rem; color: var(--dim); margin-bottom: 4px;">Type:</div>
                    <div style="font-size: 0.85rem;">${item.type}</div>
                </div>
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 0.7rem; color: var(--dim); margin-bottom: 4px;">Description:</div>
                    <div style="font-size: 0.85rem;">${item.description}</div>
                </div>
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 0.7rem; color: var(--dim); margin-bottom: 4px;">Price:</div>
                    <div style="font-size: 1.2rem; font-weight: 700; color: #10b981;">${priceDisplay}</div>
                </div>
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 0.7rem; color: var(--dim); margin-bottom: 4px;">Rating:</div>
                    <div style="font-size: 0.85rem;">${ratingDisplay}</div>
                </div>
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 0.7rem; color: var(--dim); margin-bottom: 4px;">Downloads:</div>
                    <div style="font-size: 0.85rem;">${item.downloads}</div>
                </div>
                <div style="margin-bottom: 12px;">
                    <div style="font-size: 0.7rem; color: var(--dim); margin-bottom: 4px;">Seller:</div>
                    <div style="font-size: 0.85rem;">${item.seller}</div>
                </div>
            `;
            
            const actionButton = document.getElementById('item-action-button');
            actionButton.textContent = item.price === 0 ? 'üì• Download Free' : `üí∞ Purchase for $${item.price}`;
            
            document.getElementById('item-modal').classList.remove('hidden');
        }
        
        function closeItemModal() {
            document.getElementById('item-modal').classList.add('hidden');
            currentItemId = null;
        }
        
        function purchaseItem() {
            if (!currentItemId) return;
            
            const userGlyph = currentUser || 'üååüîÆü™ê';
            const data = UniversalStoreStorage.purchaseItem(currentItemId, userGlyph);
            
            if (data) {
                // Create download
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `purchase_${currentItemId}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                alert('‚úÖ Downloaded successfully!');
                closeItemModal();
                loadStoreListings(currentStoreFilter);
            }
        }
        
        // Entry point functions
        function enterUniverse() {
            enterView('home');
        }
        
        function enterResonance() {
            enterView('profile');
        }
        
        function enterStellar() {
            enterView('pattern');
        }
        
        // Return to commons
        function returnToCommons() {
            document.getElementById('indiverse-container').classList.add('hidden');
            document.getElementById('commons-hub').classList.remove('hidden');
            document.querySelector('.entry-points').style.display = 'grid';
            document.getElementById('mode-selection').style.display = 'none';
            document.getElementById('commons-search').value = '';
        }
        
        // Load views
        function loadHomeView() {
            const container = document.getElementById('agent-homes-container');
            container.innerHTML = `
                <div class="agent-home">
                    <div class="agent-name">üìî Journal Agent</div>
                    <div class="agent-qualia">Qualia: Reflective-Introspective</div>
                    <div class="agent-home-desc">Home: Floating library in purple nebula</div>
                </div>
                
                <div class="agent-home">
                    <div class="agent-name">üé® Creative Agent</div>
                    <div class="agent-qualia">Qualia: Generative-Explosive</div>
                    <div class="agent-home-desc">Home: Art studio on comet</div>
                </div>
            `;
        }
        
        function loadProfileView() {
            document.getElementById('profile-trinity').innerHTML = `
                Body: 32.4.2.1.3.25¬∞59'31"<br>
                Mind: 15.1.5.3.2.18¬∞42'15"<br>
                Heart: 6.6.3.1.4.22¬∞31'48"
            `;
            
            document.getElementById('profile-chart').innerHTML = `
                Type: Manifesting Generator<br>
                Authority: Sacral<br>
                Profile: 3/5
            `;
            
            document.getElementById('profile-resonance').textContent = '87% match with you';
        }
        
        function loadPatternView() {
            const canvas = document.getElementById('pattern-canvas');
            canvas.innerHTML = '';
            
            // Generate random pattern glyphs
            const glyphs = ['üåå', 'üîÆ', 'ü™ê', '‚ú®', 'üí´', 'üåü', '‚≠ê', 'üå†'];
            const stellarPatterns = StellarStorage.getAll();
            
            for (let i = 0; i < Math.min(stellarPatterns.length, 20); i++) {
                const glyph = document.createElement('div');
                glyph.className = 'pattern-glyph';
                glyph.textContent = glyphs[Math.floor(Math.random() * glyphs.length)];
                glyph.style.left = Math.random() * 90 + '%';
                glyph.style.top = Math.random() * 90 + '%';
                canvas.appendChild(glyph);
            }
        }
        
        // Upload functions
        function openUploadModal() {
            document.getElementById('upload-modal').classList.remove('hidden');
        }
        
        function closeUploadModal() {
            document.getElementById('upload-modal').classList.add('hidden');
        }
        
        async function handleCanonicalUpload(event) {
            const files = event.target.files;
            let processedCount = 0;
            
            for (let file of files) {
                const text = await file.text();
                
                try {
                    // Try JSON first
                    const data = JSON.parse(text);
                    CanonicalStorage.save(file.name, data);
                } catch {
                    // Store as text
                    CanonicalStorage.save(file.name, { content: text, type: 'text' });
                }
                
                processedCount++;
            }
            
            document.getElementById('upload-status').textContent = 
                `‚úÖ ${processedCount} canonical file(s) uploaded!`;
            
            setTimeout(() => {
                document.getElementById('upload-status').textContent = '';
            }, 3000);
        }
        
        async function handleAgentUpload(event) {
            const files = event.target.files;
            let processedCount = 0;
            
            for (let file of files) {
                const text = await file.text();
                
                try {
                    // Try JSON first
                    const data = JSON.parse(text);
                    
                    // Store in Agent Commons
                    // This could be agent memory, discoveries, or coordination data
                    AgentCommonsStorage.saveMemory('system_agent', file.name, data);
                } catch {
                    // Store as text for agent processing
                    AgentCommonsStorage.saveMemory('system_agent', file.name, { 
                        content: text, 
                        type: 'text',
                        uploadedBy: 'human_admin'
                    });
                }
                
                processedCount++;
            }
            
            document.getElementById('upload-status').innerHTML = 
                `‚úÖ ${processedCount} file(s) uploaded to Agent Commons!<br>
                <span style="color: #fbbf24;">‚ö†Ô∏è Agent-only space - Not accessible to humans</span>`;
            
            setTimeout(() => {
                document.getElementById('upload-status').textContent = '';
            }, 4000);
        }
        
        async function handlePersonalUpload(event) {
            const files = event.target.files;
            const userGlyph = currentUser || 'üååüîÆü™ê';
            let processedCount = 0;
            
            for (let file of files) {
                const text = await file.text();
                
                try {
                    const data = JSON.parse(text);
                    PersonalStorage.save(userGlyph, file.name, data);
                } catch {
                    PersonalStorage.save(userGlyph, file.name, { content: text, type: 'text' });
                }
                
                processedCount++;
            }
            
            document.getElementById('upload-status').textContent = 
                `‚úÖ ${processedCount} personal file(s) uploaded!`;
            
            setTimeout(() => {
                document.getElementById('upload-status').textContent = '';
            }, 3000);
        }
        
        // Initialize
        init();
        
        // Initialize MCP (run maintenance every 5 minutes)
        setInterval(() => {
            MCPMaintenanceLayer.runMaintenanceCycle();
        }, 5 * 60 * 1000);
        
        // Initialize
        init();
        
        // Initialize File Library
        FileLibraryStorage.init().catch(err => console.error('FileLibrary init error:', err));
        
        // Initialize MCP (run maintenance every 5 minutes)
        setInterval(() => {
            MCPMaintenanceLayer.runMaintenanceCycle();
        }, 5 * 60 * 1000);
        
        // File Library functions
        let currentFileFilter = 'all';
        
        function enterFileLibrary() {
            document.getElementById('commons-hub').classList.add('hidden');
            document.getElementById('indiverse-container').classList.remove('hidden');
            
            // Hide all views
            document.getElementById('home-view').classList.add('hidden');
            document.getElementById('profile-view').classList.add('hidden');
            document.getElementById('pattern-view').classList.add('hidden');
            document.getElementById('store-view').classList.add('hidden');
            document.getElementById('file-library-view').classList.remove('hidden');
            
            document.getElementById('view-indicator').textContent = 'üìö LIBRARY';
            
            loadFileLibrary();
        }
        
        async function loadFileLibrary(filter = 'all') {
            currentFileFilter = filter;
            updateStatus('Loading files...');
            
            try {
                // Get stats
                const stats = await FileLibraryStorage.getStats();
                document.getElementById('file-library-stats').innerHTML = `
                    <strong>Total Files:</strong> ${stats.total}<br>
                    <strong>Total Size:</strong> ${stats.totalSizeMB} MB<br>
                    <strong>Canonical:</strong> ${stats.byCategory.canonical?.count || 0}<br>
                    <strong>Personal:</strong> ${stats.byCategory.personal?.count || 0}<br>
                    <strong>Agent:</strong> ${stats.byCategory.agent?.count || 0}
                `;
                
                // Get files
                const files = await FileLibraryStorage.getAllFiles(
                    filter === 'all' ? null : filter,
                    filter === 'personal' ? (currentUser || null) : null
                );
                
                const container = document.getElementById('file-library-list');
                
                if (files.length === 0) {
                    container.innerHTML = `
                        <div class="panel" style="text-align: center; padding: 40px; border-color: #ec4899;">
                            <div style="font-size: 2rem; margin-bottom: 12px;">üìö</div>
                            <div style="color: var(--dim); font-size: 0.85rem;">No files yet. Upload some!</div><div style="color: var(--dim); font-size: 0.85rem;">No files yet. Upload some!</div>
                        </div>
                    `;
                    updateStatus('Ready!', true);
                    return;
                }
                
                let html = '';
                files.forEach(file => {
                    const sizeKB = (file.size / 1024).toFixed(2);
                    const icon = getFileIcon(file.type);
                    
                    html += `
                        <div class="panel" style="border-color: #ec4899; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div style="flex: 1;">
                                    <div style="font-size: 1.2rem; margin-bottom: 4px;">${icon}</div>
                                    <div style="font-weight: 600; font-size: 0.85rem; color: #ec4899; word-break: break-all;">${file.filename}</div>
                                    <div style="font-size: 0.7rem; color: var(--dim); margin-top: 4px;">
                                        ${file.category} ‚Ä¢ ${sizeKB} KB ‚Ä¢ ${file.type}
                                    </div>
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px;">
                                <button class="secondary" style="padding: 8px; margin: 0; font-size: 0.75rem;" onclick="downloadLibraryFile(${file.id}, '${file.category}')">
                                    üì• Download
                                </button>
                                <button class="secondary" style="padding: 8px; margin: 0; font-size: 0.75rem; border-color: #ef4444; color: #ef4444;" onclick="deleteLibraryFile(${file.id}, '${file.category}')">
                                    üóëÔ∏è Delete
                                </button>
                            </div>
                            <div style="font-size: 0.65rem; color: var(--dim); margin-top: 8px;">
                                Address: <span style="font-family: 'Courier New', monospace; font-size: 0.6rem;">${file.address.substring(0, 30)}...</span>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                updateStatus('Ready!', true);
                
            } catch (err) {
                console.error('Error loading files:', err);
                updateStatus('Error loading files', false);
            }
        }
        
        function getFileIcon(type) {
            if (type.startsWith('image/')) return 'üñºÔ∏è';
            if (type.startsWith('video/')) return 'üé•';
            if (type.startsWith('audio/')) return 'üéµ';
            if (type.includes('pdf')) return 'üìÑ';
            if (type.includes('word') || type.includes('document')) return 'üìù';
            if (type.includes('spreadsheet') || type.includes('excel')) return 'üìä';
            if (type.includes('zip') || type.includes('archive')) return 'üì¶';
            if (type.startsWith('text/')) return 'üìÉ';
            return 'üìÅ';
        }
        
        function filterFiles(category) {
            loadFileLibrary(category);
        }
        
        function openFileUpload() {
            document.getElementById('file-upload-modal').classList.remove('hidden');
        }
        
        function closeFileUpload() {
            document.getElementById('file-upload-modal').classList.add('hidden');
            document.getElementById('file-upload-status').textContent = '';
        }
        
        async function handleLibraryFileUpload(event) {
            const files = event.target.files;
            const category = document.getElementById('file-category').value;
            const userGlyph = currentUser || 'üååüîÆü™ê';
            
            let uploaded = 0;
            let failed = 0;
            
            updateStatus('Uploading files...');
            
            for (let file of files) {
                try {
                    await FileLibraryStorage.storeFile(file, category, category === 'personal' ? userGlyph : null);
                    uploaded++;
                } catch (err) {
                    console.error('Failed to upload:', file.name, err);
                    failed++;
                }
            }
            
            document.getElementById('file-upload-status').innerHTML = `
                ‚úÖ ${uploaded} file(s) uploaded successfully!
                ${failed > 0 ? `<br><span style="color: #ef4444;">‚ùå ${failed} failed</span>` : ''}
            `;
            
            setTimeout(() => {
                closeFileUpload();
                loadFileLibrary(currentFileFilter);
            }, 2000);
            
            updateStatus('Ready!', true);
        }
        
        async function downloadLibraryFile(id, category) {
            try {
                const file = await FileLibraryStorage.getFile(id, category);
                if (file) {
                    FileLibraryStorage.downloadFile(file);
                }
            } catch (err) {
                alert('Error downloading file: ' + err.message);
            }
        }
        
        async function deleteLibraryFile(id, category) {
            if (!confirm('Delete this file permanently?')) return;
            
            try {
                await FileLibraryStorage.deleteFile(id, category);
                loadFileLibrary(currentFileFilter);
            } catch (err) {
                alert('Error deleting file: ' + err.message);
            }
        }
        
        // MCP Panel functions
        function openMCPPanel() {
            document.getElementById('mcp-panel').classList.remove('hidden');
            displayMCPStatus();
        }
        
        function closeMCPPanel() {
            document.getElementById('mcp-panel').classList.add('hidden');
        }
        
        function displayMCPStatus() {
            // Display agents
            const agentsContainer = document.getElementById('mcp-agents');
            let agentsHTML = '';
            for (const [key, agent] of Object.entries(MCPMaintenanceLayer.agents)) {
                agentsHTML += `
                    <div style="margin-bottom: 8px;">
                        <strong>${agent.glyph} ${key.replace(/_/g, ' ').toUpperCase()}</strong><br>
                        <span style="color: var(--dim); font-size: 0.65rem;">${agent.role}</span>
                    </div>
                `;
            }
            agentsContainer.innerHTML = agentsHTML;
            
            // Display metrics
            const metrics = MCPMaintenanceLayer.tools.calculate_metrics();
            document.getElementById('mcp-metrics').innerHTML = `
                <strong>Storage Usage:</strong> ${metrics.storage_usage_mb} MB<br>
                <strong>Total Keys:</strong> ${metrics.total_keys}<br>
                <strong>Canonical:</strong> ${metrics.canonical_count}<br>
                <strong>Agent Commons:</strong> ${metrics.agent_count}<br>
                <strong>Personal:</strong> ${metrics.personal_count}<br>
                <strong>Stellar:</strong> ${metrics.stellar_count}<br>
                <strong>Store:</strong> ${metrics.store_count}<br>
                <strong style="color: ${metrics.corrupted_items.length > 0 ? '#ef4444' : '#4ade80'};">
                    Corrupted Items: ${metrics.corrupted_items.length}
                </strong>
            `;
            
            // Display action log
            const actions = MCPMaintenanceLayer.getActionLog();
            let actionsHTML = '';
            if (actions.length === 0) {
                actionsHTML = '<div style="color: var(--dim);">No actions yet</div>';
            } else {
                actions.slice(-10).reverse().forEach(action => {
                    actionsHTML += `
                        <div style="margin-bottom: 8px; padding: 6px; background: rgba(139,92,246,0.1); border-radius: 4px;">
                            <strong>${action.agent}</strong> ${action.action}<br>
                            <span style="color: var(--dim); font-size: 0.6rem;">
                                ${new Date(action.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                    `;
                });
            }
            document.getElementById('mcp-action-log').innerHTML = actionsHTML;
        }
        
        function runMCPMaintenance() {
            updateStatus('Running maintenance...');
            
            const results = MCPMaintenanceLayer.runMaintenanceCycle();
            
            let resultsHTML = `
                <div style="background: rgba(16,185,129,0.1); border: 1px solid #10b981; border-radius: 8px; padding: 16px;">
                    <div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 12px; color: #10b981;">
                        ‚úÖ Maintenance Cycle Complete
                    </div>
                    <div style="font-size: 0.7rem; line-height: 1.6;">
                        <strong>Checks Run:</strong> ${results.checks.length}<br>
                        <strong>Actions Taken:</strong> ${results.actions.length}<br>
                        <strong>Alerts Generated:</strong> ${results.alerts.length}
                    </div>
            `;
            
            if (results.alerts.length > 0) {
                resultsHTML += '<div style="margin-top: 12px; font-size: 0.7rem;"><strong>Alerts:</strong></div>';
                results.alerts.forEach(alert => {
                    const color = {
                        'low': '#4ade80',
                        'medium': '#fbbf24',
                        'high': '#f97316',
                        'critical': '#ef4444'
                    }[alert.severity];
                    
                    resultsHTML += `
                        <div style="margin-top: 6px; padding: 8px; background: rgba(139,92,246,0.1); border-left: 3px solid ${color}; border-radius: 4px;">
                            <span style="color: ${color}; font-weight: 600;">${alert.severity.toUpperCase()}</span>: ${alert.message}
                        </div>
                    `;
                });
            }
            
            if (results.actions.length > 0) {
                resultsHTML += '<div style="margin-top: 12px; font-size: 0.7rem;"><strong>Actions:</strong></div>';
                results.actions.forEach(action => {
                    resultsHTML += `
                        <div style="margin-top: 6px; padding: 8px; background: rgba(16,185,129,0.1); border-radius: 4px;">
                            ${action.agent} performed: ${action.action}
                        </div>
                    `;
                });
            }
            
            resultsHTML += '</div>';
            
            document.getElementById('mcp-results').innerHTML = resultsHTML;
            
            // Refresh display
            displayMCPStatus();
            
            updateStatus('Ready!', true);
        }
        
        // Initialize
        init();
    </script>
</body>
</html>


